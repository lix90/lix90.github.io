<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lix is Blogging</title>
  <subtitle>菜鸟笔记，原创不多</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="blog.alexiangli.com/"/>
  <updated>2017-01-01T03:19:51.000Z</updated>
  <id>blog.alexiangli.com/</id>
  
  <author>
    <name>Lix</name>
    <email>xiangli90@outlook.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>学习 LIMO EEG</title>
    <link href="blog.alexiangli.com/learn_limo_eeg/"/>
    <id>blog.alexiangli.com/learn_limo_eeg/</id>
    <published>2016-12-31T16:00:00.000Z</published>
    <updated>2017-01-01T03:19:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据准备">数据准备</h1>
<ol>
<li>save a matrix of single trials 保存单试次矩阵。</li>
<li>update the EEG.etc field 更新 EEG.etc 域。</li>
</ol>
<p><strong>如何创建单试次矩阵数据？</strong></p>
<p><strong>创建单个数据集的单试次数据矩阵</strong><br>
使用 <code>limo_create_single_trials</code> 函数</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">options = &#123;<span class="string">'format'</span>,<span class="string">'matrix'</span>, ...</div><div class="line">           <span class="string">'datatype'</span>, <span class="string">'channels'</span>, ...</div><div class="line">           <span class="string">'erp'</span>,<span class="string">'off'</span>,...</div><div class="line">           <span class="string">'spec'</span>,<span class="string">'on'</span>,...</div><div class="line">           <span class="string">'ersp'</span>,<span class="string">'off'</span>,...</div><div class="line">           <span class="string">'itc'</span>,<span class="string">'on'</span>,...</div><div class="line">           <span class="string">'rmicacomps'</span>,<span class="string">'on'</span>, ...</div><div class="line">           <span class="string">'erpparams'</span>,[],...</div><div class="line">           <span class="string">'specparams'</span>,[],...</div><div class="line">           <span class="string">'erspparams'</span>,[],...</div><div class="line">           <span class="string">'interp'</span>,<span class="string">'off'</span>, ...</div><div class="line">           <span class="string">'scalp'</span>,<span class="string">'off'</span>,...</div><div class="line">           <span class="string">'recompute'</span>,<span class="string">'on'</span>,...</div><div class="line">           <span class="string">'savetrials'</span>,<span class="string">'on'</span> &#125;;</div><div class="line">           <span class="comment">% erpparams, specparams, erspparams 对应为 str_precomp 中对应的参数，分别对应 std_erp, std_spec, std_ersp 中的参数。默认的参数并没有自动内插缺失的通道。</span></div><div class="line">limo_create_single_trials(<span class="string">'my_subject.set'</span>, options&#123;:&#125;);</div></pre></td></tr></table></figure>
<p>使用图形界面：<code>LIMO GUI &gt; LIMO Tools &gt; create single trials</code></p>
<p><strong>创建多个数据集的单试次数据矩阵</strong></p>
<ul>
<li>创建保存数据集文件名列表的文本文件，然后导入即可批量创建多个数据集的单试次数据矩阵；</li>
<li>通过 EEGLAB STUDY 界面</li>
</ul>
<h1 id="1st-level-analysis-一阶分析">1st level analysis 一阶分析</h1>
<p>一阶分析至少需要两种文件 (categorical variable 和 continuous variables) 的其中一种。</p>
<blockquote>
<p>LIMO EEG expect (at least for now) that your have your conditions coded separately for each trial - this should be a single vector with all your conditions (basically you can export this from your EEG structure). A continuous might some measures from your stimuli, the response (like coding incorrect responses to remove some variance), or RTs.</p>
<p>Your <strong>categorical variable</strong> is basically your condition code for each epoch. I assume you have an epoched dataset? If so, for each file you need to generate a list with an integer per row corresponding to the order of trials in your epoched file. The <strong>continuous variable</strong> would be the same but it would not bin your data into condition. So for example it would be the degree of brightness for each picture (hence, continuous).</p>
<p>As Bastien point out, any integer works – also if there are some conditions you want to remove you could just put a NaN. Files can be .mat or .txt</p>
<p>Extracted from: <a href="https://sccn.ucsd.edu/pipermail/eeglablist/2014/007978.html" target="_blank" rel="external">https://sccn.ucsd.edu/pipermail/eeglablist/2014/007978.html</a></p>
</blockquote>
<p>其中，categorical variable 可以由 <code>limo_read_events.m</code> 函数生成:</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">markders = &#123;<span class="string">'marker1'</span>, <span class="string">'marker2'</span>&#125;;</div><div class="line"><span class="built_in">cat</span> = limo_read_events(data.set, markers);</div></pre></td></tr></table></figure>
<h1 id="2nd-level-analysis-二阶分析">2nd level analysis 二阶分析</h1>
<p>创建 expected channels 和 neighbouring channels</p>
<p><code>channeighbstructmat = limo_expected_chanlocs(data_set_name, path, neighbour_distance);</code><br>
<code>[neighbours, channeighbstructmat] = limo_get_channeighbstructmat(EEG, neighbdist);</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据准备&quot;&gt;数据准备&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;save a matrix of single trials 保存单试次矩阵。&lt;/li&gt;
&lt;li&gt;update the EEG.etc field 更新 EEG.etc 域。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;stro
    
    </summary>
    
      <category term="Original" scheme="blog.alexiangli.com/categories/Original/"/>
    
    
      <category term="EEG" scheme="blog.alexiangli.com/tags/EEG/"/>
    
      <category term="LIMO EEG" scheme="blog.alexiangli.com/tags/LIMO-EEG/"/>
    
      <category term="Matlab" scheme="blog.alexiangli.com/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>学习 MNE</title>
    <link href="blog.alexiangli.com/learn_mne/"/>
    <id>blog.alexiangli.com/learn_mne/</id>
    <published>2016-12-31T16:00:00.000Z</published>
    <updated>2017-01-13T17:13:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本的数据分析">基本的数据分析</h1>
<h2 id="数据合并">数据合并</h2>
<p><code>raw1.append(raw2, preload=False)</code><br>
说明：有时候，记录和保存数据时，每个被试的数据集是分段存储的，这时需要将一个被试的数据合并成单个数据集。</p>
<h2 id="数据读取">数据读取</h2>
<p>MNE 文档: <a href="http://martinos.org/mne/stable/manual/io.html#importing-eeg-data" target="_blank" rel="external">Importing EEG data</a></p>
<ul>
<li>Brainvision (.vhdr): <code>mne.io.read_raw_brainvision()</code></li>
<li>European data format (.edf): <code>mne.io.read_raw_edf()</code></li>
<li>Biosemi data format (.bdf): <code>mne.io.read_raw_edf()</code></li>
<li>Neuroscan CNT data format (.cnt): <code>mne.io.read_raw_cnt()</code></li>
<li>EGI simple binary (.egi): <code>mne.io.read_raw_egi()</code> 注意：需要从 EGI Netstation 从到处为 <code>simple binary file</code></li>
<li>EEGLAB set files (.set): <code>mne.io.read_raw_eeglab()</code> 和 <code>mne.read_epochs_eeglab()</code></li>
</ul>
<h2 id="对通道的操作">对通道的操作</h2>
<h3 id="选择通道">选择通道</h3>
<p><code>raw.pick_types(meg=False, eeg=True, eog=True)</code><br>
说明：限制为 EEG 和 EOG 通道。<br>
<code>raw.pick_types(include = ['Fz'])</code><br>
说明：选择指定的通道，并返回下标<br>
<code>raw.set_channel_types(mapping={'EOG 061': 'eeg'})</code><br>
说明：改变通道的类型，在这里将 <code>EOG 061</code> 改为 EEG 通道。<br>
<code>raw.rename_channels(mapping={'EOG 061': 'EOG'})</code><br>
说明：对通道重新命名</p>
<h3 id="读取并加载通道位置文件">读取并加载通道位置文件</h3>
<p><a href="http://martinos.org/mne/stable/generated/mne.channels.read_montage.html?highlight=montage#mne.channels.read_montage" target="_blank" rel="external"><code>mne.channels.read_montage()</code></a><br>
说明：通过指定 <code>kind</code> 和 <code>path</code> 参数指定通道位置文件的类型。</p>
<ul>
<li>kind: 指定内置通道位置文件，<code>standard_1005</code> <code>standard_1020</code> 等</li>
<li>path: 通道位置文件的外部文件路径</li>
</ul>
<p><code>data_obj.set_montage()</code><br>
说明：数据对象均有一个可以设置通道位置文件类型的方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">montage = mne.channels.read_montage(<span class="string">'standard_1020'</span>)</div><div class="line">raw.set_montage(montage)</div></pre></td></tr></table></figure>
<h2 id="查看数据">查看数据</h2>
<p>MNE 中的不同类型的数据对象均有绘图方法 <code>data_obj.plot*</code>。</p>
<h2 id="标记和删除坏道">标记和删除坏道</h2>
<p><code>data_obj.info['bads'] = ['bads_channels_label']</code><br>
说明：将坏道信息保存在数据对象的 <code>info</code> 属性对象的 <code>bads</code> 属性中。坏道应该尽早发现，排除坏道对后面分析的影响。<br>
<code>picks = mne.pick_types(raw.info, meg=False, eeg=True, exclude='bads')</code></p>
<h2 id="自动识别坏道">自动识别坏道</h2>
<p>使用 autoreject 模块中的 Ransac 算法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> autoreject <span class="keyword">import</span> Ransac</div></pre></td></tr></table></figure>
<h2 id="恢复在线参考点">恢复在线参考点</h2>
<p><code>mne.add_reference_channels(data_obj, ref_channels, copy=True/False)</code><br>
说明：有时需要恢复在线参考点的数据到原始数据结构中，然后更改参考点。这个函数所做的事情就是增加一个在线参考点到数据中，将它的值设为0。</p>
<h2 id="重参考">重参考</h2>
<p><code>mne.set_eeg_reference(data_obj, ref_channels, copy=False/True)</code><br>
说明：<code>ref_channels</code> 为字符串列表，保存通道名称。如果 <code>ref_channels = None</code> 那么执行的为平均参考（默认）；如果为多个通道，那么参考点为多个通道的均值。有时再更改为平均参考时，会出现异常。这是需要将应用自定义的参考点设为 <code>raw.info[&quot;custom_ref_applied&quot;] = False</code>，然后再进行平均参考。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">raw = mne.io.read_raw_brainvision(filepath)</div><div class="line">raw.info[<span class="string">'custom_ref_applied'</span>] = <span class="keyword">False</span></div><div class="line">raw_avg_ref, _ = mne.io.set_eeg_reference(raw, ref_channels=<span class="keyword">None</span>)</div></pre></td></tr></table></figure>
<h2 id="滤波">滤波</h2>
<ul>
<li><code>mne.filter.band_pass_filter</code> 带通滤波</li>
<li><code>mne.filter.band_stop_filter</code> 带阻滤波</li>
<li><code>mne.filter.high_pass_filter</code> 高通滤波</li>
<li><code>mne.filter.low_pass_filter</code> 低通滤波</li>
<li><code>mne.filter.notch_filter</code> 凹陷滤波</li>
<li><code>mne.filter.detrend</code> 去趋势化</li>
</ul>
<p>作为对象的方法使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">raw.filter(<span class="number">1</span>, <span class="number">40</span>, l_trans_bandwidth=<span class="number">0.5</span>, h_trans_bandwidth=<span class="string">'auto'</span>,</div><div class="line">                   filter_length=<span class="string">'auto'</span>, phase=<span class="string">'zero'</span>, fir_window=<span class="string">'hann'</span>)</div></pre></td></tr></table></figure>
<h2 id="分段">分段</h2>
<p><code>events = mne.find_events(raw)</code><br>
说明：从原始数据中提取事件。</p>
<p><code>mne.make_fixed_length_events</code> 按固定长度设置事件，然后可以由得到的事件将数据分为等长的 epoch。</p>
<p>使用字典定义事件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">events_id = &#123;</div><div class="line">    <span class="string">'label1'</span>: <span class="number">1</span>,</div><div class="line">    <span class="string">'label2'</span>: <span class="number">2</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">reject = dic(grad=<span class="number">4000e-13</span>, mag=<span class="number">4e-12</span>, eog=<span class="number">150e-6</span>)</div><div class="line">epochs = mne.Epochs(raw, events, event_id = <span class="number">1</span>, tmin=<span class="number">-0.2</span>, tmax=<span class="number">0.5</span>,</div><div class="line">                    proj = <span class="keyword">True</span>, picks=picks, baseline=(<span class="keyword">None</span>, <span class="number">0</span>),</div><div class="line">                    preload=<span class="keyword">True</span>, reject=reject)</div></pre></td></tr></table></figure>
<p>使用 <code>mne.Epochs</code> 进行分段。基线矫正通过 <code>baseline</code> 参数指定。如果基线为 <code>(None, None)</code>，那么将整段epoch的均值做基线。</p>
<h2 id="降采样率">降采样率</h2>
<p>数据对象均具有一个 <code>resample</code> 的方法。</p>
<h2 id="识别和标记坏段">识别和标记坏段</h2>
<p>peak-to-peak去伪迹<br>
指定 <code>reject</code> 的阈限：<code>reject = dict(grad=4000e-13, mag=4e-12, eog=150e-6)</code>。<br>
然后作为 <code>reject</code> 形参的实参传入 <code>mne.Epochs()</code>。</p>
<p>删除坏段<br>
<code>epochs.drop_bad()</code></p>
<p>自动检测坏试次：使用 autoreject 模块。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> autoreject <span class="keyword">import</span> LocalAutoRejectCV, Ransac</div><div class="line">ar = LocalAutoRejectCV(verbose=<span class="string">'tqdm'</span>)</div><div class="line">epochs_clean = ar.fit_transform(epochs)</div></pre></td></tr></table></figure>
<h2 id="独立成分分析">独立成分分析</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># preppare</span></div><div class="line"><span class="keyword">import</span> mne</div><div class="line"><span class="keyword">from</span> mne.preprocessing <span class="keyword">import</span> ICA</div><div class="line"><span class="keyword">from</span> mne.preprocessing <span class="keyword">import</span> create_eog_epochs, create_ecg_epochs</div><div class="line"></div><div class="line"><span class="comment"># read dataset</span></div><div class="line">raw = mne.io.read_raw_fif(raw_fname, preload=<span class="keyword">True</span>, add_eeg_ref=<span class="keyword">False</span>)</div><div class="line">raw.filter(<span class="number">1</span>, <span class="number">40</span>, n_jobs=<span class="number">2</span>)</div><div class="line">picks_meg = mne.pick_types(raw.info, meg=<span class="keyword">True</span>, eeg=<span class="keyword">False</span>, eog=<span class="keyword">False</span>, stim=<span class="keyword">False</span>, exclude=<span class="string">'bads'</span>)</div><div class="line"></div><div class="line"><span class="comment"># artifact correction</span></div><div class="line"></div><div class="line"><span class="comment">#  fit ica</span></div><div class="line">ica = ICA(n_components=<span class="number">25</span>, method=<span class="string">'fastica'</span>, random_state=<span class="number">23</span>)</div><div class="line"></div><div class="line"><span class="comment"># 剔除极端的伪迹</span></div><div class="line">reject = dict(mag=<span class="number">5e-12</span>, grad=<span class="number">4000e-13</span>)</div><div class="line"></div><div class="line"><span class="comment"># ica fit</span></div><div class="line">ica.fit(raw, picks=picks_meg, decim=decim, reject=reject)</div><div class="line"></div><div class="line"><span class="comment"># plot ica components</span></div><div class="line">ica.plot_components()</div><div class="line"></div><div class="line"><span class="comment"># inspect component properties</span></div><div class="line">ica.plot_properties(raw, picks=<span class="number">0</span>)</div></pre></td></tr></table></figure>
<p>MNE 支持三种 ICA 算法：fastica, infomax, extended-infomax</p>
<h2 id="剔除眼动伪迹">剔除眼动伪迹</h2>
<h3 id="ica">ICA</h3>
<p>如果有 EOG 通道：EOG 与成分之间的相关系数</p>
<p>如果没有 EOG 通道：使用 corrmap 算法</p>
<h3 id="ssp">SSP</h3>
<p>需要有 EOG 通道</p>
<h2 id="内插坏道">内插坏道</h2>
<p><code>epoch_clean.interpolate_bads(reset_bads = True/False, mode = 'accurate')</code></p>
<p>说明：实现标记并在 <code>info</code> 对象中保存了 <code>bads</code> 坏道的属性。然后就可以对数据对象使用 <code>interpolate_bads</code> 方法执行内插。<code>reset_bads</code> 参数表示是否移除 <code>info</code> 中的 <code>bads</code> 坏道信息。</p>
<h2 id="可视化">可视化</h2>
<h3 id="查看事件相关电位">查看事件相关电位</h3>
<h3 id="查看功率谱">查看功率谱</h3>
<h3 id="查看时頻分析">查看时頻分析</h3>
<h2 id="统计检验">统计检验</h2>
<p>非参数时空聚类置换检验</p>
<p>Prepare the input data</p>
<p>Set cluster threshold</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> scipy.stats.t <span class="keyword">import</span> ppf</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">p_accept = <span class="number">0.01</span></div><div class="line">tail = <span class="number">0.</span> <span class="comment"># for two sided test</span></div><div class="line"></div><div class="line"><span class="comment"># ----------------</span></div><div class="line">p_thresh = p_accept / (<span class="number">1</span> + (tail == <span class="number">0</span>))</div><div class="line">n_samples = len(data)</div><div class="line">threshold = -ppf(p_thresh, n_samples - <span class="number">1</span>)</div><div class="line"><span class="keyword">if</span> np.sign(tail) &lt; <span class="number">0</span>:</div><div class="line">    threshold = -threshold</div></pre></td></tr></table></figure>
<p>Make <code>connectivity</code> in <code>spatio_temporal_cluster_stats</code><br>
创建邻近通道矩阵</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> spatial</div><div class="line"><span class="keyword">import</span> mne</div><div class="line"></div><div class="line">lay = mne.channels.make_eeg_layout(contrast.info)</div><div class="line">neigh = spatial.Delaunay(lay.pos[:, :<span class="number">2</span>]).vertices</div><div class="line">connectivity = mne.surface.mesh_edges(neigh)</div></pre></td></tr></table></figure>
<h1 id="其他高级分析">其他高级分析</h1>
<h2 id="并行计算">并行计算</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> mne.parallel <span class="keyword">import</span> parallel_func</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_func</span><span class="params">()</span>:</span></div><div class="line">    <span class="comment">## code</span></div><div class="line"></div><div class="line"><span class="comment"># run parallel computing</span></div><div class="line">parallel, run_func, _ = parallel_func(run_func, n_jobs=N_JOBS)</div><div class="line">parallel(run_func(subject_id) <span class="keyword">for</span> subject_id <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">20</span>))</div></pre></td></tr></table></figure>
<h2 id="源定位">源定位</h2>
<h3 id="make-noise-covariance-matrix">Make noise covariance matrix</h3>
<h3 id="make-digitized-points-of-eeg">Make digitized points of EEG</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> mne.channels <span class="keyword">import</span> (read_montage,</div><div class="line">                          read_dig_montage)</div><div class="line"></div><div class="line">montage = read_montage(<span class="string">'standard_1020'</span>)</div><div class="line">positions = montage.pos</div><div class="line">labels = montage.ch_names</div><div class="line">labels[<span class="number">2</span>] = <span class="string">'nasion'</span></div><div class="line">digitization = read_dig_montage(hsp=positions,</div><div class="line">                                elp=positions,</div><div class="line">                                point_names=labels,</div><div class="line">                                unit=<span class="string">'mm'</span>)</div><div class="line">raw.set_montage(digitization)</div><div class="line">raw.save()</div></pre></td></tr></table></figure>
<h3 id="make-trans-file">Make trans file</h3>
<p>Coregister an MRI with a subject’s head shape</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mne coreg <span class="_">-d</span> SUBJECTS_DIR <span class="_">-s</span> SUBJECT <span class="_">-f</span> INST</div></pre></td></tr></table></figure>
<p><code>SUBJECTS_DIR</code> Subjects directory<br>
<code>SUBJECT</code> Subject name<br>
<code>INST</code> FIFF file with digitizer data for coregistration</p>
<p>Tutorial: <a href="http://www.slideshare.net/mne-python/mnepython-coregistration" target="_blank" rel="external">MNE-Python: Coregistration</a></p>
<h3 id="make-the-bem-model">Make the BEM model</h3>
<h3 id="build-the-forward-model-and-inverse-operator">Build the forward model and inverse operator</h3>
<hr>
<p>Hello Florian,</p>
<p>I do source reconstruction with EEG 64 channels and using fsaverage average brain from FreeSurfer too.</p>
<p>I had the same problem. I was trying to get the trans file using mne coreg but my EEG data did not have the dig points. So what I did is <strong>to use the standard 10-20 electrode positions</strong> that I read using montage function, when loading the data.</p>
<p>I <strong>copied the positions of the EEG channels and the fiducial points into the <a href="http://raw.info" target="_blank" rel="external">raw.info</a>[‘dig’] structure, saved the new raw file as .fif</strong> and then when I <strong>loaded it in mne correg</strong> I would <strong>see the digitized points over the fsaverage brain</strong> I previously selected.</p>
<p>Let me know if you don’t know how to do it and I will try to help you but basically you just need to copy the positions into this info structure. <strong>Make sure LPA, RPA and nazion are ordered as dig structure requieres</strong>, just in case. You can <strong>load mne sample data set and check how this <a href="http://raw.info" target="_blank" rel="external">raw.info</a>[‘dig’] structure has to be</strong>.</p>
<p>Hope it helps although if you need more help I can send you my code or try to be more specific. I am not in the office now and I don’t exactly remember how I did it. But it is basically what I am telling you now.</p>
<p>Marina.</p>
<hr>
<p>In general there is nothing different from MEG and EEG analysis, so<br>
the tutorial would look identical except the initial raw file would<br>
only have EEG data. <strong>The only real additional consideration you have is<br>
that your BEM has a much greater influence on EEG data than on MEG</strong>, so<br>
you may want to think about including special MRI sequences like the<br>
multi-echo FLASH for generating your BEM.</p>
<hr>
<p>use a standard montage with electrodes constrained on a sphere. If you want<br>
to use a BEM model you need to rescale fsaverage. The coreg GUI in mne-python<br>
allows you to do this AFAIK.</p>
<h2 id="连通性">连通性</h2>
]]></content>
    
    <summary type="html">
    
      将 EEGLAB 中使用的分析流程用 MNE 实现一遍。
    
    </summary>
    
      <category term="Original" scheme="blog.alexiangli.com/categories/Original/"/>
    
    
      <category term="EEG" scheme="blog.alexiangli.com/tags/EEG/"/>
    
      <category term="Python" scheme="blog.alexiangli.com/tags/Python/"/>
    
      <category term="MNE" scheme="blog.alexiangli.com/tags/MNE/"/>
    
  </entry>
  
  <entry>
    <title>使用 zotero 管理文献</title>
    <link href="blog.alexiangli.com/use-zotero/"/>
    <id>blog.alexiangli.com/use-zotero/</id>
    <published>2016-12-28T16:00:00.000Z</published>
    <updated>2017-01-04T08:22:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-zotero？">什么是 <a href="https://www.zotero.org/" target="_blank" rel="external">zotero</a>？</h1>
<p>zotero 是一个免费开源的文献管理软件。相似的软件有：<br>
免费开源：JabRef，docear，easybib(貌似闭源)<br>
商业付费（有的也提供免费或试用功能）：endnotes，mendeley，readcube，colwiz，paperpile（适合使用 google docs 写论文） …</p>
<p>据说在 windows 操作系统且搭配 Microsoft Word，endnotes 使用效果最佳。我没有在 windows 下使用过 endnotes，没有发言权。<br>
有的人还说，JabRef 和 LaTeX/BibTeX 配合最为默契，我也没有用过，以后有机会尝试。</p>
<h1 id="为什么使用-zotero？">为什么使用 zotero？</h1>
<ul>
<li>免费＋开源。</li>
<li>多平台支持：MacOS/Windows/Linux/Firefox (Extension)。</li>
<li>支持云端同步：100M 的容量，比较小，但是可以通过其他同步盘同步数据。</li>
<li>众多插件，高度自定义。</li>
<li>支持多种办公套件：Microsoft Office/LibreOffice/OpenOffice/NeoOffice。</li>
<li>纯文本解决方案：ODF/RTF 格式可以使用<a href="https://zotero-odf-scan.github.io/zotero-odf-scan/" target="_blank" rel="external">标记语法</a>插入，然后通过 <a href="https://zotero-odf-scan.github.io/zotero-odf-scan/" target="_blank" rel="external">ODF/RTF Scan</a> 插件扫描转换为指定引文格式的文档。</li>
<li>支持浏览器插件导入引文信息：支持 Chrome/Firefox/Safari 浏览器。</li>
<li>支持众多引文格式。</li>
<li>支持笔记功能。</li>
<li>支持群组，可进行团队协作。</li>
<li>如果你爱折腾，还可以写插件拓展你想要的功能。</li>
</ul>
<h1 id="为什么不使用-zotero？">为什么不使用 zotero？</h1>
<ul>
<li>已经习惯了其他文献管理软件</li>
<li>嫌弃它的云端存储容量太小（100MB）：但可以通过其他同步盘同步数据</li>
<li>我已找不到其他不使用 zotero 的理由了，所以放心使用 zotero 吧</li>
</ul>
<h1 id="使用流程">使用流程</h1>
<p><strong>注册账号</strong><br>
前往 <a href="https://www.zotero.org/" target="_blank" rel="external">zotero官网</a> 注册。</p>
<p><strong>安装桌面版</strong><br>
从 <a href="https://www.zotero.org/" target="_blank" rel="external">zotero官网</a> 获取，三大操作系统均支持。</p>
<p><strong>安装浏览器插件</strong><br>
仍然从官网获取浏览器插件。如果使用的是 Chrome 浏览器，暂时无法翻墙，可以将插件包下载下来，然后拖入插件管理页面。如果可以翻墙，那么直接从应用商店获取安装。</p>
<p><strong>了解首选项/参数设置</strong><br>
使用一个软件或者应用，应该习惯性地看看首选项或者参数设置。<br>
zotero 的首选项有几个地方需要更改：</p>
<ul>
<li>同步 &gt; 同步服务器：登陆账号同步</li>
<li>同步 &gt; 文件同步：取消附件同步</li>
<li>导出 &gt; 便捷复制：更改为你需要的格式</li>
<li>导出 &gt; 字符编码：为了更大的兼容性，更改字符编码为 Unicode (UTF-8)</li>
<li>引用：安装对应的办公软件插件</li>
<li>高级 &gt; 文件和文件夹：更改数据存储位置为自定义，这是为了方便使用第三方同步盘同步数据</li>
</ul>
<p><strong>添加引文数据</strong><br>
引文添加有以下几种手段：</p>
<ul>
<li>通过浏览器插件自动从网页上抓取（推荐）</li>
<li>导入带有元数据的 pdf 文件，自动抓取其中的数据</li>
<li>手动添加：支持众多的文献类型</li>
<li>导入引文数据包，支持多种格式</li>
</ul>
<p><strong>使用浏览器插件抓取引文数据</strong><br>
zotero 浏览器插件支持大多数的携带有元数据的网页，包括期刊，图书，视频，普通网页等等，具体包括哪些试试就知道了。这里有一点需要注意：在你抓取的同时，zotero 桌面软件是正在运行的。请选中对应的文献库分类（左侧我的文献库中的分类），通过浏览器插件抓取的数据会导入至 zotero 中你当前选中的分类中。</p>
<p><strong>建立引文附件副本</strong><br>
zotero 支持将引文条目对应的 pdf 文档拷贝到统一路径下方便同步管理。zotero 支持将 pdf 文件按照元数据自动重命名。</p>
<p><strong>做笔记</strong><br>
zotero 支持单独的或者与引文条目关联的富文本笔记。</p>
<p><strong>导出pdf中的注释</strong><br>
当你对某条目关联的 pdf 文档进行了高亮或者其他方式注释，可以一键导出为对应的引文条目下的笔记，并且还保留了 pdf 中文档位置信息。点击对应的位置链接，即可跳转到 pdf 中该注释的位置。这是 zotero 非常强大的一个地方，但是该功能是通过一个插件（ZotFile）提供支持的。插件从官网插件页面获取，或者搜索引擎检索：zotero + 插件名。</p>
<p><strong>交叉引用／关联文献</strong><br>
可以通过关联文献来更高校的管理文献，当你查阅一个条目时，即可快速跳转到相关的文献。当然，关联文献需要你事先手动进行关联。</p>
<p><strong>快速导入引文</strong><br>
有以下方式快速导入引文：</p>
<ul>
<li>快捷键复制到剪贴板然后粘贴：请查看“首选项 &gt; 高级 &gt; 快捷键”。</li>
<li>通过菜单中的编辑中的选项“复制引文”和“复制引文目录”复制到剪贴板然后粘贴。</li>
<li>通过弹出条目对应的右键菜单，选择“由所选条目创建引文目录”。</li>
<li>直接选中条目拖拽到相应的文本编辑窗口。</li>
</ul>
<p><strong>在办公软件中插入引文</strong><br>
首选确保对应办公软件的 zotero 插件已经安装成功。安装成功后，便可在软件中查看到 zotero 插件的工具图标。不同版本的办公软件可能现实的位置不一样。例如，Mac 下的 Microsoft Word 2015，zotero 在“加载项”中。<br>
该插件提供了以下功能：</p>
<ul>
<li>插入引文：支持单篇或多篇引文。</li>
<li>插入引文时添加前缀或后缀：以 (see Author, 2014 for review) 为例，see 为前缀，for review 为后缀。</li>
<li>插入引文时可选择省略作者，因为此时作者已在文中出现，只需插入年份。</li>
<li>插入引文时添加页码。</li>
<li>编辑插入后的引文和引文目录：edit citation/bibliography</li>
<li>对引文进行了修改，可以点击刷新 bibliography</li>
</ul>
<p><strong>建立群组进行团队协作与共享</strong><br>
在新建分类的按钮旁边有一个新建群组文献库的按钮，点击将打开 zotero 网址登陆并新建群组。群组支持公开的，也支持私有的。私有的群组可以邀请成员加入群组，这样一来，就可以一个小团队或者合作者之间共同管理文献。</p>
<h1 id="结束语">结束语</h1>
<p>至此，zotero 几乎解决了你在写论文文献管理过程中所有问题。如果需要一些个性化的功能支持，还可以去 zotero 论坛求助或者自己写一个插件。zotero 的开源性质决定了它的功能也会越来越强，社区也会不断发展壮大。</p>
<h1 id="to-dos">TO-DOs</h1>
<p><strong>纯文本写论文</strong></p>
<ul>
<li>LaTeX/BibTeX + zotero</li>
<li>markdown + zotero</li>
<li>org-mode (emacs) + zotero</li>
</ul>
]]></content>
    
    <summary type="html">
    
      zotero 使用经验整理。
    
    </summary>
    
      <category term="Original" scheme="blog.alexiangli.com/categories/Original/"/>
    
    
      <category term="zotero" scheme="blog.alexiangli.com/tags/zotero/"/>
    
      <category term="bibiography" scheme="blog.alexiangli.com/tags/bibiography/"/>
    
  </entry>
  
  <entry>
    <title>谷歌学术文献检索技巧</title>
    <link href="blog.alexiangli.com/use-google-scholar/"/>
    <id>blog.alexiangli.com/use-google-scholar/</id>
    <published>2016-12-13T16:00:00.000Z</published>
    <updated>2016-12-14T10:04:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="google-scholar-谷歌学术文献检索技巧">Google Scholar 谷歌学术文献检索技巧</h1>
<p>这是我个人总结的谷歌学术检索文献的技巧，用于实验室内部分享。</p>
<h2 id="谷歌学术适合什么样的文献检索需求？">谷歌学术适合什么样的文献检索需求？</h2>
<ul>
<li>部分全文获取</li>
<li>初步或探索性地查询相关领域文献</li>
<li>查询作者/研究者的相关文献</li>
<li>快速查找少量相关文献</li>
<li>查找文献被引频次：也包含peer-reviewed以外的文献的引用</li>
<li>查找一篇文献有关联的文章</li>
<li>订阅研究者的新文献</li>
<li>…</li>
</ul>
<h2 id="谷歌学术不适合什么样的文献检索？">谷歌学术不适合什么样的文献检索？</h2>
<ul>
<li>进行系统地文献检索：例如写元分析和综述时所需要的文献检索</li>
<li>根据机构检索文献</li>
<li>一部分未公开的文献的全文</li>
<li>对引文查询结果进行统计分析</li>
<li>…</li>
</ul>
<h2 id="如何确定关键词">如何确定关键词</h2>
<p>检索用到的关键词一般为实词。为了提高检索效率，在检索前必须确定明确的关键词，请勿直接使用“句子”进行检索。在确定关键词前，请考虑同义词和词性的问题。虽然谷歌学术会帮你拓展同义词和词性，但是在头脑中形成这样的信息检索思路有助于你获取信息。</p>
<h2 id="普通检索">普通检索</h2>
<p>普通的检索直接输入关键词就可以了。这种检索比较简单，适合探索性地检索，即没有特定的目的，仅仅粗略地获取信息。但是，通过这种检索方式获取信息较为低效。建议使用限定词和检索符进行检索。</p>
<h2 id="高级检索">高级检索</h2>
<ul>
<li>时间：年份，年份范围</li>
<li>排序：相关性和日期排序</li>
<li>标题</li>
<li>作者</li>
<li>期刊</li>
</ul>
<h2 id="如何定位作者？">如何定位作者？</h2>
<ul>
<li>英文文献使用拉丁字母，中文文献使用中文</li>
<li>可以使用全称，也可以使用简称，全称更准确，简称较模糊</li>
<li>添加限定词：<code>author:</code></li>
<li>使用双引号（英文半角引号）包括姓名：<code>author:&quot;james gross&quot;</code> 或者简称 <code>author:&quot;j gross&quot;</code></li>
<li>或者手动使用搜索选项：搜索框右侧倒三角形按钮</li>
</ul>
<h2 id="如何限定标题？">如何限定标题？</h2>
<ul>
<li>使用限定词：<code>intitle:</code> 只搜索标题中出现关键字的条目</li>
<li>使用双引号：<code>intitle:&quot;emotion regulation&quot;</code></li>
</ul>
<h2 id="如何限定期刊？">如何限定期刊？</h2>
<p>谷歌学术没有针对期刊的限定词，但是可以在高级搜索框中在期刊输入框中输入对应的期刊进行检索。需要检索多个期刊时使用双引号包裹期刊名，使用 <code>OR</code> 逻辑符来分隔多个由双引号包裹的期刊名。例如：<code>&quot;emotion&quot; OR &quot;cognition &amp; emotion&quot;</code>。或者直接搜索框中输入 <code>(&quot;emotion&quot; OR &quot;cognition &amp; emotion&quot;)</code>，记得用括号包裹为一个整体。</p>
<h2 id="如何限定年份">如何限定年份</h2>
<ul>
<li>直接通过左边栏的年份选项去选择。</li>
<li>在搜索框输入年份检索（不推荐）。</li>
</ul>
<h2 id="如何检索多个并列的关键词">如何检索多个并列的关键词</h2>
<p>使用 <code>OR</code> <code>()</code> <code>&quot; &quot;</code> 来构建多个并列检索词，例如：<code>(emotion OR mood OR affect)</code>。其实这个时候并不需要 <code>()</code> 来进行包括，也同样有效。</p>
<h2 id="如何使用-and-逻辑符">如何使用 AND 逻辑符</h2>
<p>通过 <code>AND</code> 可以设定必须出现的关键词，加上 <code>OR</code> 就可以进行更为强大的检索。例如：<code>(emotion OR mood OR affect) AND (erp OR eeg OR meg OR fmri OR &quot;functional MRI&quot;)</code>。</p>
<h2 id="如何限定支持全文获取的文献">如何限定支持全文获取的文献</h2>
<ul>
<li>如果条目右侧没有出现 <code>pdf</code> 字样，不要认为就没有全文链接。点击进入 <code>所有 n 个版本</code> 链接查看是否有全文链接。</li>
<li>仅限定可获取全文的条目：使用限定词 <code>filetype:pdf</code>。例如：<code>emotion filetype:pdf</code>。</li>
</ul>
<h1 id="最后来一个更复杂的例子">最后来一个更复杂的例子</h1>
<p><code>filetype:pdf 2015 (&quot;emotion&quot; OR &quot;emotion review&quot; OR &quot;cognition and emotion&quot; OR &quot;motivation and emotion&quot;) (&quot;emotion regulation&quot; OR &quot;emotion control&quot; OR &quot;cognitive reappraisal&quot; OR &quot;emotion suppression&quot;) AND (&quot;erp&quot; OR &quot;eeg&quot; OR &quot;meg&quot; OR &quot;fmri&quot; OR &quot;functional MRI&quot; OR &quot;electroencephalography&quot; OR &quot;event related potential&quot; OR &quot;magnetoencephalography&quot;)</code></p>
<p>说明：获取特定情绪有关的期刊在2015年的文中所有地方出现相关关键词的全文条目。</p>
<p>欢迎分享与转载，但请注明出处 :)</p>
]]></content>
    
    <summary type="html">
    
      个人总结的谷歌学术文献检索技巧。
    
    </summary>
    
      <category term="Original" scheme="blog.alexiangli.com/categories/Original/"/>
    
    
      <category term="google scholar" scheme="blog.alexiangli.com/tags/google-scholar/"/>
    
      <category term="文献检索" scheme="blog.alexiangli.com/tags/%E6%96%87%E7%8C%AE%E6%A3%80%E7%B4%A2/"/>
    
      <category term="labs" scheme="blog.alexiangli.com/tags/labs/"/>
    
  </entry>
  
  <entry>
    <title>每日总结 2016-12-08</title>
    <link href="blog.alexiangli.com/r-making-contrasts/"/>
    <id>blog.alexiangli.com/r-making-contrasts/</id>
    <published>2016-12-07T16:00:00.000Z</published>
    <updated>2017-03-22T08:23:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="make-contrasts-in-r">Make contrasts in R<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></h1>
<p>两种应用 contrasts 的方式：</p>
<ul>
<li>添加 contrasts 到 data.frame 中，那么只要用到 data.frame 来构建模型，contrasts 将每次都将被使用。</li>
<li>添加 contrasts 到 model 中，那么在检验模型时就会使用到它的 contrasts。</li>
</ul>
<blockquote>
<p>By default, R uses traditional dummy coding (called “treatment contrasts” in R) for any non- ordered factors, and polynomial trend contrasts for any ordered factors. That works out well if you intend to look at regression coefficients.</p>
</blockquote>
<p>R 中默认的 contrasts 为非等级因子使用 treatment contrasts，等级因子使用 polynomial trend contrasts。这在为了考察回归系数时有效。</p>
<blockquote>
<p>Note that traditional dummy coding is fine for regression coefficients, but since traditional dummy codes aren’t orthogonal, it messes things up when you’re just trying to partition variance (i.e. an ANOVA). (Also remember that the default R anova functions use type 1 sums of squares, which is generally not what you want. To get type 3 sums of squares, use the Anova() function from the car package.)</p>
</blockquote>
<p>但是，默认的 contrasts 并不适用于需要分解方差时，即方差分析。另外，R 的方差分析函数 <code>aov</code> 使用 Type-I 平方和，而一般来说，常用 Type-III 平方和。<code>car::Anova()</code> <code>ez::ezANOVA()</code> <code>afex::aov_ez()</code> 等均支持 Type-III 平方和。</p>
<blockquote>
<p>R is still using traditional dummy coding (treatment contrasts) behind the scenes here, unlike other stats software (like SPSS) that would switch to effects coding for an ANOVA.</p>
<p>For an ANOVA, you should set your factors to use effects coding, rather than relying on the default treatment codes. You can do that with the <code>contr.sum()</code> function.</p>
<p>As long as they’re orthogonal, they’ll work fine in an ANOVA.</p>
<p>For ANOVAs, effects coding works great, orthogonal contrast coding works great, and traditional dummy coding not so much.</p>
</blockquote>
<p>如果进行方差分析，必须在进行分析之前将 contrasts 给改为 effects coding 或 orthogonal contrast coding。</p>
<blockquote>
<p>Anova() won’t show you the individual contrast results, just the overall effect of each factor. You can see the results of each contrast by using the summary() function on the model object.</p>
</blockquote>
<p>使用 <code>car::Anova()</code> 并不会显示出每个独立的比较，而仅仅显示出每个因子的总效应。可以把模型对象传入函数 <code>summary(modobj)</code>，这样就能显示出每个独立的比较的结果。</p>
<blockquote>
<p>If you use aov() instead of lm() to specify the original model, then you’ll need to add a split argument to the summary() call to see the contrast results.</p>
</blockquote>
<p>如果使用 <code>aov()</code> 建立模型，而不是 <code>lm()</code>，传入 <code>split</code> 参数到 <code>summary()</code> 才能看到比较的结果。<code>summary(..., split = list(var = list(...), ...))</code>。其中，split 参数中也可以不包含所有变量的所有水平。</p>
<blockquote>
<p>You need to be careful, though, because the contrasts() function is a sneaky little bastard, as noted above. To apply contrast weights, you’ll need to give it the inverse of your matrix of weights.</p>
</blockquote>
<p>在构建自定义的比较时，需要谨慎，因为 <code>contrasts()</code> 函数有一些小技巧，特别时当应用 contrast 权重时，需要对 contasts 矩阵进行求逆运算。</p>
<p>以下为构建自定义比较的步骤：</p>
<ol>
<li>Specfiy the weights for your contrasts (and be sure to check the order of the levels of the factor, so your weights will line up properly). 首先指定 contrasts 的权重。</li>
<li>Create a temporary matrix with each contrast as one row. The top row (for the constant) should be 1/j for j groups. 构建临时的矩阵，第一列每个元素为 1/j，如果 j 为水平数。使用 <code>rbind</code> 构建临时矩阵。</li>
<li>Get the inverse of that temporary matrix. 使用 <code>solve</code> 函数对临时矩阵求逆。</li>
<li>The first column of the inverse will be all 1’s. Drop that first column. The remaining columns are your contrast matrix. 求逆后的矩阵第一列每一个元素都为1，删除第一列，剩余的列即为最终的 contrast 矩阵。然后就可以在建立模型时传入 contrasts 参数 <code>contrasts = list(...)</code>。</li>
</ol>
<blockquote>
<p>If you specify orthogonal contrasts, the regression coefficients for each contrast should just equal the difference between those group means.</p>
</blockquote>
<p>如果指定的 contrasts 为 orthogonal，每个比较的回归系数应该等于比较的组的均值的差值。</p>
<blockquote>
<p>So what happens if you try to run your own contrasts without doing the weird inverse thing? It depends. If your contrasts are orthogonal, then the t-tests and p-values you get for the regression coefficients will all be fine, but your contrast estimates (and corresponding SEs) might not match the difference between group means you expected. If your contrasts are nonorthogonal, then failing to do the weird inverse thing can result in totally garbage estimates and useless t-tests. So you MUST do this inverse thing if you specify nonorthogonal contrasts, but you should probably get in the habbit of doing it anyway for orthogonal ones as well.</p>
</blockquote>
<p>不进行矩阵求逆会出现什么结果呢？如果 contrasts 为正交的，那么对回归系数检验的 t 值和 p 值时没有问题的，但是 contrast estimate 以及对应的标准误可能不等于比较的组的均值的差值。如果 contrasts 不是正交的，那么所得到的结果是无效的。所以，最好是对所有 contasts 权重矩阵进行求逆。</p>
<blockquote>
<p>you can get j-1 orthogonal contrasts out of a factor with j levels.</p>
<p>Yep. If you want to save time and only specify the contrast(s) you care about, you can do that, and R will come up with some orthogonal contrasts to fill in the rest. What you won’t be able to do is take the inverse of your contrast weights; you can only take the inverse of a square matrix, and if you have fewer than j-1 contrasts, your temporary matrix won’t be square. But remember: as long as your contrasts are orthogonal, your t-tests will all be fine even if you don’t do the inverse thing. So go ahead and just use the contrasts you want directly with the contrasts() function, and be aware that your contrast estimates may not accurately reflect the differences between group means.</p>
</blockquote>
<p>如果进行的比较次数少于 j-1，那么 R 会自动地计算出剩余的正交 contrasts。只不过，此时无法进行矩阵逆运算。不过只要 contrasts 是正交的，那么就不用担心检验的结果。需要考虑的是，contrast estimates 将可能不等于比较的组均值的差值。</p>
<blockquote>
<p>Note that if you add fewer than j-1 contrasts to the contrasts argument in lm(), it will NOT fill out the remaining contrasts for you. Rather, any group differences other than those represented in your contrast will get lumped into the error term!</p>
</blockquote>
<p>需要注意，如果 <code>lm()</code> 模型中 contrasts 少于 j-1 次，没有反映在 contrasts 中的组差异将被纳入到误差项中。</p>
<p><strong>问题：什么是正交的 contrasts？如何建立正交 contrasts？</strong></p>
<blockquote>
<p><strong>Orthogonal contrasts</strong> are a set of contrasts in which, for any distinct pair, <strong>the sum of the cross-products of the coefficients is zero</strong> (assume sample sizes are equal). Although there are potentially infinite sets of orthogonal contrasts, within any given set there will always be a maximum of exactly k – 1 possible orthogonal contrasts (where k is the number of group means available).</p>
</blockquote>
<blockquote>
<p>There are only k-1 orthogonal comparisons, where k is the number of factor levels.<br>
Comparisons/contrasts orthogonal to each other are statistically independent.<br>
Which of the possible comparisons should we conduct? Well, this very much depends on our hypothesis we have in mind.</p>
</blockquote>
<blockquote>
<p>We need to specify a contrast matrix, showing which comparisons we want to make. A contrast matrix consists of so-called contrast coefficients that (in the end) all have to sum to zero. This means, those things we want to compare have to get the opposite sign (e.g. +1 and –1), while those things we don ́t want to compare will receive a value of zero.</p>
</blockquote>
<blockquote>
<p>Orthogonal contrasts are planned, a priori tests that partition the experimental variance cleanly. They are a powerful tool for analyzing data, but they are not appropriate for all experiments. Less restrictive comparisons among treatment means can be performed using various means separation tests, or multiple comparison tests.</p>
</blockquote>
<ul>
<li>两个比较的向量点对点相乘的和等于0的比较为正交比较。</li>
<li>水平数为 k 的因子，最多有 k-1 次正交比较。</li>
<li>正交比较之间在统计上相对独立。</li>
<li>进行什么样的比较与研究假设相关。</li>
<li>在一个比较中，相互比较的水平之间的比较矩阵中对应的数值和为0，两者符号相反，其它水平数值为0。</li>
</ul>
<p><strong>问题：R 有哪些内置的构建 contrasts 的函数？</strong></p>
<p><code>contr.treatment()</code><br>
<code>contr.helmert()</code><br>
<code>contr.poly()</code><br>
<code>contr.sum()</code><br>
<code>contr.SAS</code></p>
<hr>
<h1 id="杂项">杂项</h1>
<blockquote>
<p>calculating post-hoc power are flawed and can produce misleading conclusions. Once a confidence interval has been computed, there is no additional information that a post hoc power calculation can provide. (Hoenig &amp; Heisey 2001)</p>
</blockquote>
<h1 id="翻译">翻译</h1>
<blockquote>
<p>We have empirically assessed the distribution of published effect sizes and estimated power by extracting more than 100,000 statistical records from about 10,000 cognitive neuroscience and psychology papers published during the past 5 years. The reported median effect size was d=0.93 (inter-quartile range: 0.64-1.46) for nominally statistically significant results and d=0.24 (0.11-0.42) for non-significant results. Median power to detect small, medium and large effects was 0.12, 0.44 and 0.73, reflecting no improvement through the past half-century. Power was lowest for cognitive neuroscience journals. 14% of papers reported some statistically significant results, although the respective F statistic and degrees of freedom proved that these were non-significant; p value errors positively correlated with journal impact factors. False report probability is likely to exceed 50% for the whole literature. In light of our findings the recently reported low replication success in psychology is realistic and worse performance may be expected for cognitive neuroscience.<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p>
</blockquote>
<p>我们从10,000篇近五年的认知神经科学和心理学已发表的期刊论文中提取了100,000份统计学记录，评估了发表的效应量 (effect sizes) 和估计的统计检验力 (power) 的统计分布。对于名义上达到统计显著性的结果中报告的效应量中位数为 d=0.93（四分位数范围为：0.64-1.46），而对于未达到统计显著性的结果，报告效应量中位数为 d=0.24 (四分位数范围：0.11-0.42)。检测到较弱，中等、较强的效应的统计检验力中位数分别为0.12，0.44，以及0.73。这表面在这几个领域内统计检验力在近半个世纪没有任何提高。其中，认知神经科学期刊论文的统计检验力最低（研究者考察了医学、心理学和认知神经科学）。14% 的论文报告了一些统计上显著的结果，然而这些结果中对应的 F 统计量和自由度均证明了这些结果并未达到显著。（有意思的是）p值的错误报告与期刊的影响因子呈正相关关系。在所有文献范围内，错误报告概率（False report probability）超过了50%。我们的结果提示，近来报告的心理学领域的低重复率问题是确实存在的，而且在认知神经科学领域可能预示着更严重的低重复率问题。</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="http://rstudio-pubs-static.s3.amazonaws.com/65059_586f394d8eb84f84b1baaf56ffb6b47f.html" target="_blank" rel="external">A (sort of) Complete Guide to Contrasts in R</a> <a href="#fnref1" class="footnote-backref">↩</a></p>
</li>
<li id="fn2" class="footnote-item"><p><a href="http://biorxiv.org/content/early/2016/08/25/071530" target="_blank" rel="external">Szucs, D., &amp; Ioannidis, J. P. (2016). Empirical assessment of published effect sizes and power in the recent cognitive neuroscience and psychology literature. bioRxiv, 071530.</a> <a href="#fnref2" class="footnote-backref">↩</a></p>
</li>
</ol>
</section>
]]></content>
    
    <summary type="html">
    
      - 如何在 R 语言中构建 contrasts&lt;br&gt;- 一篇论文摘要的翻译：心理学和认知神经科学中效应量和统计检验力使用问题
    
    </summary>
    
      <category term="Daily" scheme="blog.alexiangli.com/categories/Daily/"/>
    
    
      <category term="R" scheme="blog.alexiangli.com/tags/R/"/>
    
      <category term="Statistics" scheme="blog.alexiangli.com/tags/Statistics/"/>
    
      <category term="Effect-size" scheme="blog.alexiangli.com/tags/Effect-size/"/>
    
      <category term="Power" scheme="blog.alexiangli.com/tags/Power/"/>
    
  </entry>
  
  <entry>
    <title>R：基本数据对象</title>
    <link href="blog.alexiangli.com/r-data-type/"/>
    <id>blog.alexiangli.com/r-data-type/</id>
    <published>2016-11-23T16:00:00.000Z</published>
    <updated>2016-11-28T12:26:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vector-向量">vector 向量</h1>
<p>向量 vector 由同类型的元素构成。</p>
<h2 id="向量创建">向量创建</h2>
<p><code>vector</code> 创建给定长度和模式的向量。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; vector(mode = <span class="string">"character"</span>, length = <span class="number">5</span>)</div><div class="line">[<span class="number">1</span>] <span class="string">""</span> <span class="string">""</span> <span class="string">""</span> <span class="string">""</span> <span class="string">""</span></div></pre></td></tr></table></figure>
<p><code>as.vector</code> 可以将实参转换为给定模式的向量。如果输入结果为原子模式（atomic），属性将丢失。R 中原子模式为 “logical”, “integer”, “numeric” (“double”), “complex”, “character”, 和 “raw”。在 R 中原子模式应该就是指最基本的模式，能够组合成其他的复杂模式，例如 “list” “expression”。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; x &lt;- c(a = <span class="number">1</span>, b = <span class="number">2</span>)</div><div class="line">a b</div><div class="line"><span class="number">1</span> <span class="number">2</span></div><div class="line">&gt;&gt;&gt; is.vector(x)</div><div class="line">[<span class="number">1</span>] <span class="literal">TRUE</span></div><div class="line">&gt;&gt;&gt; as.vector(x)</div><div class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span></div><div class="line">all.equal(x, as.vector(x))</div><div class="line">[<span class="number">1</span>] <span class="string">"names for target but not for current"</span></div></pre></td></tr></table></figure>
<p><code>c</code> 可以将它的实参组合成一个向量。所有的实参都将被强制转换为通用的类型，除了 names 之外，其他属性都将丢失。输出数据类型由实参中元素的最高级类型决定（NULL &lt; raw &lt; logical &lt; integer &lt; double &lt; complex &lt; character &lt; list &lt; expression）。</p>
<p>例如：</p>
<p>转换为字符串。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; (out &lt;- c(<span class="number">1</span>, <span class="string">"2"</span>))</div><div class="line">[<span class="number">1</span>] <span class="string">"1"</span> <span class="string">"2"</span></div></pre></td></tr></table></figure>
<p>转换为 list</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; (out &lt;- c(<span class="number">1</span>, list(<span class="number">2</span>)))</div><div class="line">[[<span class="number">1</span>]]</div><div class="line">[<span class="number">1</span>] <span class="number">1</span></div><div class="line"></div><div class="line">[[<span class="number">2</span>]]</div><div class="line">[<span class="number">1</span>] <span class="number">2</span></div></pre></td></tr></table></figure>
<h2 id="向量运算">向量运算</h2>
<p><strong>向量的索引</strong><br>
<code>a[1]</code> 单个元素的索引<br>
<code>a[1:2]</code> <code>a[c(1,3)]</code> 多个元素的索引<br>
<code>a[a==5]</code> 使用逻辑值来索引<br>
<code>a[-1]</code> <code>a[c(-1,-3)]</code> 排除元素</p>
<p><strong>向量的运算</strong><br>
<code>a*2</code> 向量与2相乘，2将与向量的每一个元素相乘。<br>
<code>a*b</code> 向量与向量相乘，对应位置的元素相乘。如果 <code>a</code> 和 <code>b</code> 的长度不等长呢？试一个例子：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; v1 &lt;- c(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line">&gt;&gt;&gt; v2 &lt;- c(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>)</div><div class="line">&gt;&gt;&gt; v3 &lt;- c(<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>)</div><div class="line">&gt;&gt;&gt; v1*v2</div><div class="line">[<span class="number">1</span>] <span class="number">3</span> <span class="number">6</span> <span class="number">3</span></div><div class="line">Warning message:</div><div class="line">In v1 * v2 : 长的对象长度不是短的对象长度的整倍数</div><div class="line">&gt;&gt;&gt; v1*v3</div><div class="line">[<span class="number">1</span>] <span class="number">4</span> <span class="number">8</span> <span class="number">4</span> <span class="number">8</span></div></pre></td></tr></table></figure>
<p>也就是说，向量相乘时，若长度不相等，较短的向量会继续往后与长的向量相乘。如果向量的长度不是整数倍，会出现警告：“长的对象长度不是短的对象长度的整倍数”。</p>
<p><code>a%%2</code> 对向量所有元素求余数<br>
<code>a%/%2.4</code> 向量所有元素与2.4进行整除运算<br>
<code>t(a)</code> 对 <code>a</code> 进行转置</p>
<p><strong>总结：对于向量的运算，都是对其元素的运算。</strong></p>
<h1 id="matrix-矩阵">matrix 矩阵</h1>
<h2 id="矩阵创建">矩阵创建</h2>
<p><code>matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL)</code></p>
<ul>
<li><code>data</code> 为向量类型，非原子模式的对象将由 <code>as.vector</code> 强制转换为向量，并且去掉属性。</li>
<li><code>nrow</code> <code>ncol</code> 指定矩阵的行或列的数目，如果两个参数均未指定，那么将得到一个单列矩阵。</li>
<li><code>byrow</code> 逻辑值，若 <code>FALSE</code>（默认），矩阵按列来填充；若 <code>TRUE</code> 则按行填充。</li>
<li><code>dimnames</code> 矩阵的名称属性，<code>NULL</code> 或者长度为 list 的对象，空 list 为 <code>NULL</code>。list 的第一个元素的值被当作矩阵行的名称。list 也可以含有名称，那么 list 的名称将被当作矩阵的维度名称。</li>
</ul>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; mdat &lt;- matrix(c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>), nrow = <span class="number">2</span>, ncol = <span class="number">3</span>, byrow = <span class="literal">TRUE</span>,</div><div class="line">+ dimnames = list(c(<span class="string">"R.1"</span>, <span class="string">"R.2"</span>), c(<span class="string">"C.1"</span>, <span class="string">"C.2"</span>, <span class="string">"C.3"</span>)))</div><div class="line">&gt;&gt;&gt; mdat</div><div class="line">     C.1 C.2 C.3</div><div class="line">row1   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></div><div class="line">row2  <span class="number">11</span>  <span class="number">12</span>  <span class="number">13</span></div></pre></td></tr></table></figure>
<h2 id="矩阵运算">矩阵运算</h2>
<p><code>a[,2]</code> <code>a[1,2]</code> <code>a[c(1,2),]</code> <code>a[-2,]</code> 矩阵索引或者取子矩阵<br>
<code>rbind(a,b)</code> <code>cbind(a,c)</code> 将两个矩阵或向量按照行或者列合并</p>
<p><code>a*b</code> 一对一乘积（点积），行和列数必须匹配。<br>
<code>a%*%b</code> 矩阵乘积，<code>a</code> 的列必须等于 <code>b</code> 的行。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a &lt;- matrix(<span class="number">1</span>:<span class="number">6</span>, nrow = <span class="number">2</span>)</div><div class="line">&gt;&gt;&gt; b &lt;- matrix(<span class="number">2</span>:<span class="number">7</span>, nrow = <span class="number">3</span>)</div><div class="line">&gt;&gt;&gt; a*b</div><div class="line">Error <span class="keyword">in</span> a * b : 非整合陈列</div><div class="line">&gt;&gt;&gt; a*t(b)</div><div class="line">[,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>]</div><div class="line">[<span class="number">1</span>,]    <span class="number">2</span>    <span class="number">9</span>   <span class="number">20</span></div><div class="line">[<span class="number">2</span>,]   <span class="number">10</span>   <span class="number">24</span>   <span class="number">42</span></div><div class="line">&gt;&gt;&gt; a%*%b</div><div class="line">[,<span class="number">1</span>] [,<span class="number">2</span>]</div><div class="line">[<span class="number">1</span>,]   <span class="number">31</span>   <span class="number">58</span></div><div class="line">[<span class="number">2</span>,]   <span class="number">40</span>   <span class="number">76</span></div><div class="line">&gt;&gt;&gt; a%*%t(b)</div><div class="line">Error <span class="keyword">in</span> a %*% t(b) : 非整合参数</div></pre></td></tr></table></figure>
<p><code>apply(a, MARGIN, FUN, ...)</code> 对矩阵或数组的向量化运算，如果存在名称的话，<code>MARGIN</code> 也可为维度的名称字符串。在此只讨论对矩阵的用法。</p>
<ul>
<li><code>apply(a, MARGIN = 1, sum)</code> 对矩阵 a 的行求和。</li>
<li><code>apply(a, MARGIN = 2, sum)</code> 对矩阵 a 的列求和。</li>
<li><code>apply(a, MARGIN = C(1,2), sum)</code> 对矩阵 a 的行列求和，得到的仍为原来的矩阵。</li>
</ul>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a &lt;- matrix(<span class="number">1</span>:<span class="number">6</span>, nrow = <span class="number">2</span>)</div><div class="line">&gt;&gt;&gt; apply(a, <span class="number">1</span>, sum)</div><div class="line">[<span class="number">1</span>]  <span class="number">9</span> <span class="number">12</span></div><div class="line">&gt;&gt;&gt; apply(a, <span class="number">2</span>, sum)</div><div class="line">[<span class="number">1</span>]  <span class="number">3</span>  <span class="number">7</span> <span class="number">11</span></div><div class="line">&gt;&gt;&gt; apply(a, c(<span class="number">1</span>,<span class="number">2</span>), sum)</div><div class="line">     [,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>]</div><div class="line">[<span class="number">1</span>,]    <span class="number">1</span>    <span class="number">3</span>    <span class="number">5</span></div><div class="line">[<span class="number">2</span>,]    <span class="number">2</span>    <span class="number">4</span>    <span class="number">6</span></div></pre></td></tr></table></figure>
<p><code>diag(a)</code> 提取矩阵 a 的对角元素<br>
<code>diag(1:4)</code> 构建一个新的对角矩阵<br>
<code>crossprod(a,b)</code> 矩阵叉积，等同于 <code>t(a)%*%b</code>，前者计算效率更高。</p>
<h1 id="array-数组创建">array 数组创建</h1>
<p><code>array(data = NA, dim = length(data), dimnames = NULL)</code></p>
<p>数组可以存储两个以上维度数据。矩阵其实是特殊的两个维度的数组。<code>dim</code> 用于指定每个维度的长度。如果 <code>data</code> 数据长度不足，将会被复制循环填充。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; arr &lt;- array(<span class="number">1</span>:<span class="number">12</span>, dim = c(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>))</div><div class="line">&gt;&gt;&gt; arr</div><div class="line">, , <span class="number">1</span></div><div class="line"></div><div class="line">[,<span class="number">1</span>] [,<span class="number">2</span>]</div><div class="line">[<span class="number">1</span>,]    <span class="number">1</span>    <span class="number">3</span></div><div class="line">[<span class="number">2</span>,]    <span class="number">2</span>    <span class="number">4</span></div><div class="line"></div><div class="line">, , <span class="number">2</span></div><div class="line"></div><div class="line">[,<span class="number">1</span>] [,<span class="number">2</span>]</div><div class="line">[<span class="number">1</span>,]    <span class="number">5</span>    <span class="number">7</span></div><div class="line">[<span class="number">2</span>,]    <span class="number">6</span>    <span class="number">8</span></div><div class="line"></div><div class="line">, , <span class="number">3</span></div><div class="line"></div><div class="line">[,<span class="number">1</span>] [,<span class="number">2</span>]</div><div class="line">[<span class="number">1</span>,]    <span class="number">9</span>   <span class="number">11</span></div><div class="line">[<span class="number">2</span>,]   <span class="number">10</span>   <span class="number">12</span></div></pre></td></tr></table></figure>
<h1 id="factor-因子">factor 因子</h1>
<p>因子是一个由字符串或者整数组成的向量，用来对另外一个等长的向量进行分类的离散变量。与一般的向量不同点是 factor 具有 <code>level</code> 属性。R 提供了已排序和未排序两类 factor。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">factor(x = character(), levels, labels = levels,</div><div class="line">    exclude = <span class="literal">NA</span>, ordered = is.ordered(x), nmax = <span class="literal">NA</span>)</div></pre></td></tr></table></figure>
<ul>
<li><code>x</code> 向量，一般为少数几个不同的值。向量 <code>x</code> 的类型必须可以被转换为字符串 <code>as.character()</code> 和可以被排序 <code>sort.list</code>。</li>
<li><code>levels</code> 水平，<code>x</code> 中选择性的值构成的字符串向量。默认值为 <code>unique(as.character(x))</code>，并且增序排列。<code>levels</code> 可以少于 <code>sort(unique(x))</code>。如果 <code>levels</code> 少于 <code>sort(unique(x))</code>，<code>x</code> 中没有包含的元素将被当作 <code>NA</code>。</li>
<li><code>labels</code> 可选的参数，用来命名因子水平名称。例如，如果 <code>labels = &quot;f&quot;</code>，那么因子名为 <code>f1, f2, ...</code>。</li>
<li><code>exclude</code> 在组成 <code>levels</code> 时需要排除掉的元素。与 <code>x</code> 类型相同，否则需要强制转换。</li>
<li><code>ordered</code> 是否有序。有序的因子与未排序的因子仅仅在类上不同，但是方法和模型拟合函数对两者的处理有非常大的不同。</li>
<li><code>nmax</code> 水平数的上限。</li>
</ul>
<p><code>factor</code> 函数返回一个 “factor” 类的对象，这个对象具有和 <code>x</code> 等长的整数码，具有 “character” 模式的 “levels” 属性。如果 <code>ordered = TRUE</code> 或者使用了 <code>ordered()</code> ，那么对象则具有两个类 <code>c(&quot;ordered&quot;, &quot;factor&quot;)</code>。对因子的解释依赖于编码（codes）和水平属性（levels）两个因素，所以在对因子进行比较时需谨慎。对因子使用 <code>as.numeric</code> 没有意义，因为会自动强制转换。如果要将因子 <code>f</code> 转换为初始的数值，建议使用 <code>as.numeric(levels(f))[f]</code>，这样要比 <code>as.numeric(as.character(f))</code> 效率高。因子的水平默认进行了排序，但是排序的标准依赖本地区域设置。可能不是基于 ASCII。尽量不要使用 <code>NA</code> 作为水平值。</p>
<h2 id="因子的创建和操作">因子的创建和操作</h2>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a &lt;- c(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</div><div class="line">&gt;&gt;&gt; f &lt;- factor(a)</div><div class="line">&gt;&gt;&gt; f</div><div class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span></div><div class="line">Levels: <span class="number">1</span> <span class="number">2</span></div><div class="line"></div><div class="line"><span class="comment">## 指派了 levels 结果一致</span></div><div class="line">&gt;&gt;&gt; f &lt;- factor(a, levels = c(<span class="string">"1"</span>, <span class="string">"2"</span>))</div><div class="line">&gt;&gt;&gt; f</div><div class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span></div><div class="line">Levels: <span class="number">1</span> <span class="number">2</span></div><div class="line"></div><div class="line"><span class="comment">## levels 个数少于 a</span></div><div class="line">&gt;&gt;&gt; f &lt;- factor(a, levels = c(<span class="string">"1"</span>))</div><div class="line">&gt;&gt;&gt; f</div><div class="line">[<span class="number">1</span>] <span class="number">1</span>    <span class="number">1</span>    &lt;<span class="literal">NA</span>&gt; &lt;<span class="literal">NA</span>&gt;</div><div class="line">Levels: <span class="number">1</span></div><div class="line"></div><div class="line"><span class="comment">## 增加标签</span></div><div class="line">&gt;&gt;&gt; f &lt;- factor(a, labels = <span class="string">"x"</span>)</div><div class="line">&gt;&gt;&gt; f</div><div class="line">[<span class="number">1</span>] x1 x1 x2 x2</div><div class="line">Levels: x1 x2</div><div class="line"></div><div class="line"><span class="comment">## 增加排序</span></div><div class="line">&gt;&gt;&gt; f &lt;- factor(a, labels = <span class="string">"x"</span>, ordered = <span class="literal">TRUE</span>)</div><div class="line">&gt;&gt;&gt; f</div><div class="line">[<span class="number">1</span>] x1 x1 x2 x2</div><div class="line">Levels: x1 &lt; x2</div><div class="line"></div><div class="line"><span class="comment">## 改变 levels 的顺序</span></div><div class="line">&gt;&gt;&gt; f &lt;- factor(a, levels = c(<span class="string">"2"</span>, <span class="string">"1"</span>), labels = <span class="string">"x"</span>, ordered = <span class="literal">TRUE</span>)</div><div class="line">&gt;&gt;&gt; f</div><div class="line">[<span class="number">1</span>] x2 x2 x1 x1</div><div class="line">Levels: x1 &lt; x2</div></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">## 构建一个 data.frame</span></div><div class="line">&gt;&gt;&gt; c.1 &lt;- rep(c(<span class="string">"f1"</span>, <span class="string">"f2"</span>), each = <span class="number">3</span>)</div><div class="line">&gt;&gt;&gt; c.2 &lt;- <span class="number">1</span>:<span class="number">6</span></div><div class="line">&gt;&gt;&gt; d &lt;- data.frame(c.1, c.2)</div><div class="line">&gt;&gt;&gt; d</div><div class="line">  c.1 c.2</div><div class="line"><span class="number">1</span>  f1   <span class="number">1</span></div><div class="line"><span class="number">2</span>  f1   <span class="number">2</span></div><div class="line"><span class="number">3</span>  f1   <span class="number">3</span></div><div class="line"><span class="number">4</span>  f2   <span class="number">4</span></div><div class="line"><span class="number">5</span>  f2   <span class="number">5</span></div><div class="line"><span class="number">6</span>  f2   <span class="number">6</span></div><div class="line"></div><div class="line"><span class="comment">## 将 c.1 转换为因子</span></div><div class="line">&gt;&gt;&gt; (d$c.1 &lt;- factor(c.1))</div><div class="line">[<span class="number">1</span>] f1 f1 f1 f2 f2 f2</div><div class="line">Levels: f1 f2</div><div class="line"></div><div class="line"><span class="comment">## 或者使用 as.factor</span></div><div class="line">&gt;&gt;&gt; as.factor(d$c.1)</div><div class="line">[<span class="number">1</span>] f1 f1 f1 f2 f2 f2</div><div class="line">Levels: f1 f2</div><div class="line"></div><div class="line"><span class="comment">## 进行一个排序</span></div><div class="line">&gt;&gt;&gt; factor(d$c.1, levels = c(<span class="string">"f2"</span>, <span class="string">"f1"</span>), ordered = <span class="literal">TRUE</span>)</div><div class="line">[<span class="number">1</span>] f1 f1 f1 f2 f2 f2</div><div class="line">Levels: f2 &lt; f1</div><div class="line"></div><div class="line">&gt;&gt;&gt; factor(d$c.1, levels = c(<span class="string">"f1"</span>, <span class="string">"f2"</span>), ordered = <span class="literal">TRUE</span>)</div><div class="line">[<span class="number">1</span>] f1 f1 f1 f2 f2 f2</div><div class="line">Levels: f1 &lt; f2</div><div class="line"></div><div class="line"><span class="comment">## 或者使用 ordered</span></div><div class="line">&gt;&gt;&gt; ordered(d$c.1, levels = c(<span class="string">"f1"</span>, <span class="string">"f2"</span>))</div><div class="line">[<span class="number">1</span>] f1 f1 f1 f2 f2 f2</div><div class="line">Levels: f1 &lt; f2</div><div class="line"></div><div class="line">&gt;&gt;&gt; ordered(d$c.1, levels = c(<span class="string">"f2"</span>, <span class="string">"f1"</span>))</div><div class="line">[<span class="number">1</span>] f1 f1 f1 f2 f2 f2</div><div class="line">Levels: f2 &lt; f1</div><div class="line"></div><div class="line"><span class="comment">## 转换因子的数据模式</span></div><div class="line">&gt;&gt;&gt; as.character(d$c.1)</div><div class="line">[<span class="number">1</span>] <span class="string">"f1"</span> <span class="string">"f1"</span> <span class="string">"f1"</span> <span class="string">"f2"</span> <span class="string">"f2"</span> <span class="string">"f2"</span></div><div class="line"></div><div class="line">&gt;&gt;&gt; as.numeric(d$c.1)</div><div class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span></div><div class="line"></div><div class="line">&gt;&gt;&gt; as.logical(d$c.1)</div><div class="line">[<span class="number">1</span>] <span class="literal">NA</span> <span class="literal">NA</span> <span class="literal">NA</span> <span class="literal">NA</span> <span class="literal">NA</span> <span class="literal">NA</span></div></pre></td></tr></table></figure>
<h1 id="list-列表">list 列表</h1>
<p>list 是 R 中比较宽松的数据类型，它可以由类型不一致的任意对象构成。list 非常适合用于封装函数的输出对象。list 的元素可以使用 <code>$</code> <code>[]</code> <code>[[]]</code> 访问。</p>
<p><code>l = list(tag1 = value1, tag2 = value2, ..., tagn = valuen)</code></p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; x = list(a = <span class="number">1</span>:<span class="number">10</span>, beta = exp(-<span class="number">3</span>:<span class="number">3</span>),</div><div class="line">+ logic = c(<span class="literal">TRUE</span>,<span class="literal">FALSE</span>,<span class="literal">FALSE</span>,<span class="literal">TRUE</span>))</div><div class="line"></div><div class="line">&gt;&gt;&gt; x</div><div class="line">$a</div><div class="line">[<span class="number">1</span>]  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span></div><div class="line"></div><div class="line">$beta</div><div class="line">[<span class="number">1</span>]  <span class="number">0.04978707</span>  <span class="number">0.13533528</span>  <span class="number">0.36787944</span>  <span class="number">1.00000000</span>  <span class="number">2.71828183</span>  <span class="number">7.38905610</span></div><div class="line">[<span class="number">7</span>] <span class="number">20.08553692</span></div><div class="line"></div><div class="line">$logic</div><div class="line">[<span class="number">1</span>]  <span class="literal">TRUE</span> <span class="literal">FALSE</span> <span class="literal">FALSE</span>  <span class="literal">TRUE</span></div><div class="line"></div><div class="line">&gt;&gt;&gt; x$a</div><div class="line">[<span class="number">1</span>]  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span></div><div class="line">&gt;&gt;&gt; x[<span class="number">1</span>]</div><div class="line">$a</div><div class="line">[<span class="number">1</span>]  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span></div><div class="line"></div><div class="line">&gt;&gt;&gt; x[[<span class="number">1</span>]]</div><div class="line">[<span class="number">1</span>]  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span></div><div class="line">&gt;&gt;&gt; x[[<span class="number">1</span>]][<span class="number">1</span>]</div><div class="line">[<span class="number">1</span>] <span class="number">1</span></div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p><code>apply</code> 函数簇中 <code>lapply</code> 函数可以对 list 进行向量化运算，返回的数据类型也是 list。<code>sapply</code> 同样支持 list 类型的参数，但是默认返回的数据类型为 vector。但是当传入参数 <code>simplify = FALSE</code>，返回 list。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; lapply(x, mean)</div><div class="line">$a</div><div class="line">[<span class="number">1</span>] <span class="number">5.5</span></div><div class="line"></div><div class="line">$beta</div><div class="line">[<span class="number">1</span>] <span class="number">4.535125</span></div><div class="line"></div><div class="line">$logic</div><div class="line">[<span class="number">1</span>] <span class="number">0.5</span></div><div class="line"></div><div class="line">&gt;&gt;&gt; sapply(x, mean)</div><div class="line">       a     beta    logic</div><div class="line"><span class="number">5.500000</span> <span class="number">4.535125</span> <span class="number">0.500000</span></div><div class="line"></div><div class="line">&gt;&gt;&gt; class(lapply(x,mean))</div><div class="line">[<span class="number">1</span>] <span class="string">"list"</span></div><div class="line"></div><div class="line">&gt;&gt;&gt; class(sapply(x,mean))</div><div class="line">[<span class="number">1</span>] <span class="string">"numeric"</span></div><div class="line"></div><div class="line">&gt;&gt;&gt; is.matrix(sapply(x,mean))</div><div class="line">[<span class="number">1</span>] <span class="literal">FALSE</span></div><div class="line"></div><div class="line">&gt;&gt;&gt; is.vector(sapply(x,mean))</div><div class="line">[<span class="number">1</span>] <span class="literal">TRUE</span></div><div class="line"></div><div class="line">&gt;&gt;&gt; is.list(sapply(x,mean,simplify = <span class="literal">FALSE</span>))</div><div class="line">[<span class="number">1</span>] <span class="literal">TRUE</span></div></pre></td></tr></table></figure>
<p>其他与 list 有关的函数</p>
<p><code>unlist(x, recursive = TRUE, use.names = TRUE)</code> 将 list 展开，转换为 vector</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; unlist(x)</div><div class="line">         a1          a2          a3          a4          a5          a6</div><div class="line"> <span class="number">1.00000000</span>  <span class="number">2.00000000</span>  <span class="number">3.00000000</span>  <span class="number">4.00000000</span>  <span class="number">5.00000000</span>  <span class="number">6.00000000</span></div><div class="line">         a7          a8          a9         a10       beta1       beta2</div><div class="line"> <span class="number">7.00000000</span>  <span class="number">8.00000000</span>  <span class="number">9.00000000</span> <span class="number">10.00000000</span>  <span class="number">0.04978707</span>  <span class="number">0.13533528</span></div><div class="line">      beta3       beta4       beta5       beta6       beta7      logic1</div><div class="line"> <span class="number">0.36787944</span>  <span class="number">1.00000000</span>  <span class="number">2.71828183</span>  <span class="number">7.38905610</span> <span class="number">20.08553692</span>  <span class="number">1.00000000</span></div><div class="line">     logic2      logic3      logic4</div><div class="line"> <span class="number">0.00000000</span>  <span class="number">0.00000000</span>  <span class="number">1.00000000</span></div></pre></td></tr></table></figure>
<p><code>as.list(x, all.names = FALSE, sorted = FALSE, ...)</code> 将对象数据类型转换为 list<br>
<code>is.list(x)</code> 检测数据类型是否为 list</p>
<h1 id="data-frame-数据框">Data.frame 数据框</h1>
<p>data.frame 是 R 中非常重要的数据类型，它长得像 matrix，但是又与 list 一样，可以存储不同类型的数据，但是有一个每列数据长度必须一致。同样，data.frame 数据的访问与 matrix 和 list 类似。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">data.frame(<span class="keyword">...</span>, row.names = <span class="literal">NULL</span>, check.rows = <span class="literal">FALSE</span>,</div><div class="line">           check.names = <span class="literal">TRUE</span>,</div><div class="line">           stringsAsFactors = default.stringsAsFactors())</div></pre></td></tr></table></figure>
<p>参数</p>
<ul>
<li><code>...</code> 参数形式为 value 或者 tag = value，value 为数据内容，tag 为列名。</li>
<li><code>row.names</code> 行的名称</li>
<li><code>check.rows</code> 是否检测行数和名称是否一致。</li>
<li><code>check.names</code> 是否检测列的名称的合法性以及是否重复，有必要的话，通过 <code>make.names</code> 调整名称。</li>
<li><code>stringsAsFactors</code> 是否将字符向量转换为因子类型。如果不想让某个对象被强行转换类型，可以用 <code>I(a)</code> 包裹。</li>
</ul>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; d &lt;- data.frame(c1 = rep(c(<span class="string">"f1"</span>, <span class="string">"f2"</span>), each = <span class="number">3</span>), c2 = <span class="number">1</span>:<span class="number">6</span>)</div><div class="line">&gt;&gt;&gt; d</div><div class="line">  c1 c2</div><div class="line"><span class="number">1</span> f1  <span class="number">1</span></div><div class="line"><span class="number">2</span> f1  <span class="number">2</span></div><div class="line"><span class="number">3</span> f1  <span class="number">3</span></div><div class="line"><span class="number">4</span> f2  <span class="number">4</span></div><div class="line"><span class="number">5</span> f2  <span class="number">5</span></div><div class="line"><span class="number">6</span> f2  <span class="number">6</span></div><div class="line"></div><div class="line">&gt;&gt;&gt; d$c1</div><div class="line">[<span class="number">1</span>] f1 f1 f1 f2 f2 f2</div><div class="line">Levels: f1 f2</div><div class="line"></div><div class="line">&gt;&gt;&gt; d[<span class="number">1</span>]</div><div class="line">c1</div><div class="line"><span class="number">1</span> f1</div><div class="line"><span class="number">2</span> f1</div><div class="line"><span class="number">3</span> f1</div><div class="line"><span class="number">4</span> f2</div><div class="line"><span class="number">5</span> f2</div><div class="line"><span class="number">6</span> f2</div><div class="line"></div><div class="line">&gt;&gt;&gt; d[<span class="number">1</span>,<span class="number">2</span>]</div><div class="line">[<span class="number">1</span>] <span class="number">1</span></div><div class="line"></div><div class="line">&gt;&gt;&gt; d[<span class="string">"c1"</span>]</div><div class="line">c1</div><div class="line"><span class="number">1</span> f1</div><div class="line"><span class="number">2</span> f1</div><div class="line"><span class="number">3</span> f1</div><div class="line"><span class="number">4</span> f2</div><div class="line"><span class="number">5</span> f2</div><div class="line"><span class="number">6</span> f2</div><div class="line"></div><div class="line">&gt;&gt;&gt; d[<span class="string">"c1"</span>][<span class="number">1</span>,]</div><div class="line">[<span class="number">1</span>] f1</div><div class="line">Levels: f1 f2</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      本文总结了下 R 语言中基本的几种数据对象，包括：向量、矩阵、多维数组、因子、列表、数据框。内容几乎全部从 R 语言内置文档阅读获取。
    
    </summary>
    
      <category term="Original" scheme="blog.alexiangli.com/categories/Original/"/>
    
      <category term="R" scheme="blog.alexiangli.com/categories/Original/R/"/>
    
    
      <category term="R" scheme="blog.alexiangli.com/tags/R/"/>
    
      <category term="R-basics" scheme="blog.alexiangli.com/tags/R-basics/"/>
    
  </entry>
  
  <entry>
    <title>关于 EEGLAB 分析 EGI 数据</title>
    <link href="blog.alexiangli.com/eeg-eeglab-egi/"/>
    <id>blog.alexiangli.com/eeg-eeglab-egi/</id>
    <published>2016-11-20T16:00:00.000Z</published>
    <updated>2017-07-07T07:12:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>EEGLAB 作为通用型脑电数据分析的工具包，理论上适用于所有脑电设备记录的数据。问题在于，如果 EEGLAB 未提供原生的 EGI (Electrical Geodesics Incorporated) 数据格式的导入，那么如何转换格式导入数据。另外就是获取并导入匹配的电极位置文件。除了原始数据的导入和电极位置文件的加载，后续分析同其他格式数据一致。</p>
<h1 id="数据导入">数据导入</h1>
<p>原生的2009版的 EGI 文件与 EEGLAB 并不兼容，需要转换为 Netstation 二进制文件（Netstation binary simple）。对于新版本的 EGI 文件的读取，有两种解决方案。</p>
<ul>
<li>第一种为使用 EEGLAB 插件；</li>
<li>第二种为使用 File-IO。</li>
</ul>
<p>EGI 文件也可以转换为 EDF 文件后导入 EEGLAB，但是这会导致“事件”（mark）的损坏或丢失。所以应该选择转换为 Netstation 二进制文件。</p>
<p><code>pop_readegi</code> 函数可用于读取 EGI 版本2和版本3的数据文件。EGI 格式文件的事件存储在专门的 EGI 数据通道。该通道的信息将被自动地导入到 EEGLAB 的事件表中，然后被 EEGLAB 从数据中剔除。如果导入事件通道失败，可以手动提取事件信息（<code>File &gt; Import event info &gt; From data channel</code>）。</p>
<p>当前新版原生的 Netstation 文件无法直接导入到 EEGLAB/Matlab 中。可以通过 Netstation software 将数据转换为 Netstation 二进制文件。虽然 Netstation 也可以导出为 EDF 文件，但是储存事件信息的通道丢失了。</p>
<p>如果单个被试的文件没分为多个数据段，可以在 EEGLAB 中一同导入 <code>File &gt; Import data &gt; From multiple seg. Nestation files</code>。</p>
<p>Nestation 也可以把数据导出为 Matlab 文件，然后再通过 EEGLAB 导入 Matlab 文件 <code>File &gt; Import data &gt; From Netstation epoch Matlab files</code>。这种方法仍然会丢失许多信息。</p>
<p><strong>总结：先将数据从 Netstation 中导出为二进制文件，然后通过 EEGLAB 导入。</strong></p>
<h1 id="电极位置文件">电极位置文件</h1>
<p>电极位置文件可以从 <a href="ftp://ftp.egi.com/pub/support/3rdPartySoftwareSupport/BESA/" target="_blank" rel="external">EGI ftp site</a> 获取。另外，EEGLAB 自带了一些电极位置文件，位于 EEGLAB 根目录下的 <code>sample_locs</code> 文件夹下的 <code>GSM*.sfp</code> 文件。</p>
<p>参考资料：</p>
<ul>
<li><a href="https://sccn.ucsd.edu/wiki/A01:_Importing_Continuous_and_Epoched_Data#Importing_Netstation.2FEGI_files" target="_blank" rel="external">Importing Continuous and Epoched Data: Importing Netstation/EGI files</a></li>
<li><a href="https://sccn.ucsd.edu/wiki/Channel_Location_Files" target="_blank" rel="external">Channel Location Files</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      最近需要指导一位访问学习的博士师兄分析脑电数据，涉及到 EGI 设备的数据格式，记录下通过 EEGLAB 如何导入 EGI 记录的脑电数据。
    
    </summary>
    
      <category term="Original" scheme="blog.alexiangli.com/categories/Original/"/>
    
      <category term="EEG" scheme="blog.alexiangli.com/categories/Original/EEG/"/>
    
    
      <category term="EEG" scheme="blog.alexiangli.com/tags/EEG/"/>
    
      <category term="EGI" scheme="blog.alexiangli.com/tags/EGI/"/>
    
      <category term="EEGLAB" scheme="blog.alexiangli.com/tags/EEGLAB/"/>
    
  </entry>
  
  <entry>
    <title>西服保养建议</title>
    <link href="blog.alexiangli.com/life-clean-suit/"/>
    <id>blog.alexiangli.com/life-clean-suit/</id>
    <published>2016-11-20T16:00:00.000Z</published>
    <updated>2016-11-28T12:40:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>声明：内容整理自：</p>
<ul>
<li><a href="https://www.zhihu.com/question/23243060" target="_blank" rel="external">知乎：西装在平时应该如何保养？应该如何清洗？普先生、赵远方等人回答</a></li>
<li><a href="http://www.merino.com/cn/wool/care-instructions/cleaning-a-wool-suit/" target="_blank" rel="external">Merino：羊毛西装的清洁</a></li>
</ul>
<h1 id="清洗">清洗</h1>
<ul>
<li><strong>干洗</strong>。只在必要时才选择干洗。找专门而可靠的干洗店，减少染毛和毛料被烫坏的可能。</li>
<li><strong>按需干洗，一年一次</strong>。一般西服最高耐用年限为 4-5年，顶尖品牌的西服也只能保证干洗6次以内不起泡。一套西装每年最多干洗三次。</li>
<li><strong>及时清除污渍</strong>。小范围污渍使用局部清洗法。在产生污渍的最短时间内用蘸水或少许清洁剂的布轻轻擦拭，不能太用力，否则污渍会嵌入到面料中。干洗时，要告知干洗店污渍残留的位置，以免疏忽造成污渍的永久残留。</li>
<li><strong>使用专门的西服刷清洁尘污</strong>。西服刷尽量选择由真正动物毛发制成的刷子。尘污会使西服失去新鲜感。当西服沾上其他纤维或较不容易去除的尘污，可以用胶带吸附。</li>
</ul>
<h1 id="穿着频率">穿着频率</h1>
<p><strong>避免疲劳穿着，一套西服不要连续穿两天以上</strong>。西服在穿过后，会因局部张力而变形，需适当“休息”，故应准备两、三套换穿。一套西服可配两条西裤替换。</p>
<h1 id="悬挂">悬挂</h1>
<ul>
<li>使用专用的木衣架（宽柄圆弧形，与肩同宽）悬挂西服，换季时储存在袋子或箱子中防潮防尘。避免使用过窄衣架，以免破坏肩型。</li>
<li>裤子的吊挂可用衣裤联合衣架，也可用带夹子的西裤专用衣架，夹住裤脚自然倒挂，有助于长期保持裤线及裤型。<br>
<img src="/img/care-suit/hang-suit.jpg" alt="悬挂西裤方法"></li>
</ul>
<h1 id="折叠">折叠</h1>
<p><img src="/img/care-suit/fold-suit-1.jpg" alt="折叠西服方法一"><br>
<img src="/img/care-suit/fold-suit-2.jpg" alt="折叠西服方法二"></p>
<h1 id="熨烫">熨烫</h1>
<ul>
<li><strong>切勿直接熨烫，使用蒸汽熏烫法</strong>。调好温度，选择蒸汽档轻轻熏烫（高品质蒸汽清洁器价格不菲）。用蒸汽熨斗对准西装喷射足够两的蒸汽。</li>
<li><strong>重点关照活动多的部位</strong>。如胳膊肘、膝盖、袖子、腰部等部位。褶皱严重的地方用蒸汽让面料吸足水后，轻轻拉平有褶皱的地方。朝四周均衡拉平，而不应该只朝一个方向拉。</li>
<li><strong>盖一层薄棉布熨烫西裤裤线</strong>。盖上薄棉布后，慢慢移动熨斗。熨完之后不应立即撤掉棉布，等降温后再撤走。<br>
<img src="/img/care-suit/press-suit.jpg" alt="熨烫西服建议"></li>
</ul>
<h1 id="防潮">防潮</h1>
<ul>
<li>收藏存放前要晾干。</li>
<li>收藏存放期间适度进行通风和晾晒。</li>
<li>选择通风干燥处的合适地点或位置收藏存放。</li>
<li>在湿度较大的收藏间存放时可使用防潮剂。用干净的白沙布定制成小袋，装入块状的氯化钙封口，并放置在衣柜，切勿将防潮袋与服装接触。另外，需要经常检查防潮袋是否仍有效。</li>
<li>使用防潮袋（布料为佳）悬挂西服。</li>
</ul>
<h1 id="防虫">防虫</h1>
<ul>
<li>使用樟脑丸时用白纸或浅色纱布包好，散放在箱柜四周，或装入小布袋中悬挂在衣柜内。</li>
<li>在使用防蛀剂时要注意它的用量。仅在存放服装的箱柜中能嗅到樟脑丸的气味为宜。</li>
</ul>
<h1 id="去亮光">去亮光</h1>
<p>久穿的西装（尤其是光面面料），在肘部和膝部易产生亮光。准备半盆清水，并往水中滴上几滴醋，把毛巾蘸湿后，用毛巾按一个方向檫几下，便可除去亮光。</p>
<h1 id="其他">其他</h1>
<ul>
<li>仔细阅读西服上的护理标签，清楚标签的含义和指示。</li>
<li>减少衣物堆积。避免西服出现皱褶和混色。</li>
<li>坐在桌旁工作时，建议脱掉西服，以免袖口及肘部跟桌子长时间摩擦变得光亮。</li>
<li>西服外兜不要拆线，以免变形不服帖，钱包和手机等可放到西服内兜。</li>
<li>久穿的毛料西服，在相对湿度 35% - 40% 环境（如洗完澡后的浴室）中放置一晚，可除去衣服细小皱纹。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      为了后面的求职面试，花“重金”买了套休闲西服。对于还未有正式收入的未毕业学生来说，略微昂贵。于是网上找了些与西服保养有关的资料，整理在此，方便以后温习。事事不能想当然，生活技能也需要学习。
    
    </summary>
    
      <category term="Notes" scheme="blog.alexiangli.com/categories/Notes/"/>
    
    
      <category term="西服保养" scheme="blog.alexiangli.com/tags/%E8%A5%BF%E6%9C%8D%E4%BF%9D%E5%85%BB/"/>
    
      <category term="Life style" scheme="blog.alexiangli.com/tags/Life-style/"/>
    
  </entry>
  
  <entry>
    <title>数据库面试题解答</title>
    <link href="blog.alexiangli.com/sql-interview/"/>
    <id>blog.alexiangli.com/sql-interview/</id>
    <published>2016-11-18T16:00:00.000Z</published>
    <updated>2016-11-28T12:42:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>内容来源：<a href="https://zhuanlan.zhihu.com/p/23713529" target="_blank" rel="external">知乎专栏-学习编程：常见面试题整理–数据库篇</a></p>
<h1 id="存储过程">存储过程</h1>
<p>什么是存储过程？优缺点？</p>
<p>存储过程：一个预编译的代码块（T-SQL），实现一系列功能（对表单或多表增删改查），然后方便调用。<br>
优点：执行效率较高；降低网络通信量，提高通信效率；一定程度上确保数据安全。</p>
<p>我的问题：如何编写存储过程代码？</p>
<h1 id="索引">索引</h1>
<p>什么是索引？作用？优缺点？使用索引查询一定能提高查询的性能吗？</p>
<p>索引：对数据库表中一或多个列的值进行<strong>排序</strong>的结构，能够<strong>加快数据检索</strong>，允许数据库程序迅速找到表中数据，而不必扫描整个数据库。<br>
MySQL中几个基本的索引：普通索引、唯一索引、主键索引、全文索引。<br>
优缺点：</p>
<ul>
<li>加快数据检索速度</li>
<li>降低增删改等维护任务的速度</li>
<li>唯一索引可以确保每一行数据的唯一性</li>
<li>可以在查询过程中使用优化隐藏器，提高系统性能</li>
<li>占物理和数据空间（缺点）</li>
</ul>
<p>然而，在使用索引查询数据时，需要注意到它的代价。<strong>索引需要存储空间，也需要定期维护</strong>，当表中记录被增减，或者索引列被修改时，索引本身也会被修改，将会因此多付出4，5次磁盘I/O。有时候，<strong>不必要的索引反而会时查询反应时间变慢</strong>，所使用索引并不一定提高查询性能。</p>
<p>索引查询适合两种情况：</p>
<ul>
<li><strong>基于一定范围的检索</strong>，一般查询返回结果集小于表中记录数的30%；</li>
<li><strong>基于非唯一性索引的检索</strong>。</li>
</ul>
<p>我的问题：如何创建索引？</p>
<h1 id="事务">事务</h1>
<p>事务（Transaction）：并发控制的基本单位。它是一个操作序列，要么执行，要么都不执行，是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，保持数据一致性。</p>
<h1 id="并发控制">并发控制</h1>
<p>乐观锁与悲观锁</p>
<p><strong>并发控制</strong>确保多个事务在同时存取数据库中同一数据时，不破坏事务的隔离性和统一性，以及数据库的统一性。乐观锁和悲观锁为并发控制的主要技术手段。</p>
<ul>
<li>悲观锁为悲观并发控制，它假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作；</li>
<li>乐观锁为乐观并发控制，它假定不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</li>
</ul>
<h1 id="删除操作">删除操作</h1>
<p>drop, delete, truncate 的区别？分别在什么场景下使用？</p>
<ul>
<li>三者均为删除操作；</li>
<li>delete 和 truncate 只删除表的数据不删除表的结构</li>
<li>速度：drop &gt; truncate &gt; delete</li>
<li>delete 语句是 dml，这个操作会放到 rollback segement 中，事务提交之后才生效；如果有相应的 trigger，执行的时候将被触发。truncate，drop 是 ddl，操作立即生效，原数据不放到 rollback segment 中，不能回滚。操作不触发 trigger。</li>
</ul>
<p>场景：</p>
<ul>
<li>不再需要一张表，用 drop；</li>
<li>删除部分数据行，用 delete，带上 where 子句；</li>
<li>保留表而删除所有数据，用 truncate。</li>
</ul>
<h1 id="键">键</h1>
<p>超键、候选键、主键、外键是什么？</p>
<p>超键：在关系中<strong>能唯一标识元组的属性集</strong>称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含<strong>候选键</strong>和<strong>主键</strong>。<br>
候选键：最小超键，即没有冗余元素的超键。<br>
主键：数据库表中对储存数据对象予以<strong>唯一和完整标识</strong>的数据列或属性的组合。<strong>一个数据列只能有一个主键</strong>，且主键的取值不能缺失，即不能为空值（Null）。<br>
外键：在一个表中存在的另一个表的主键称此表的外键。</p>
<h1 id="视图">视图</h1>
<p>什么是视图？视图的使用场景？</p>
<p>视图是一种虚拟的表，具有和物理表相同的功能，可对视图进行增，改，查的操作。视图通常是一个表或者多个表的行或列的子集。相比多表查询，使得我们获取数据更容易。对视图的修改不影响基本表。</p>
<ul>
<li>只暴露部分字段给访问者；</li>
<li>查询的数据来源于不同的表，而查询者希望以统一的方式查询，创建视图能把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异</li>
</ul>
<h1 id="范式">范式</h1>
<p>范式（Normal Form）：符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度。通俗地讲，就是一张数据表的表结构所符合的某种设计标准的级别。符合高一级范式的设计，必定符合低一级范式。范式作为设计的标准范式，其最大的意义就是为了避免数据的冗余和插入/删除/更新的异常。</p>
<p>第一范式 1NF：符合 1NF 关系中的每个属性都不可再分。也就是说，一个属性不能有子属性。1NF 是所有关系型数据库（RDB）的最基本要求。只要在关系型数据库管理系统中已经存在的数据表，一定是符合 1NF 的。如果仅仅符合 1NF 的设计，会存在数据冗余过大，插入异常，删除异常，修改异常等问题。故需要提高设计标准，解决导致上述问题的因素，使其符合更高一级范式，这就是所谓的“规范化”。</p>
<p>第二范式 2NF：2NF 在 1NF 的基础上，消除了非主属性对于码的部分函数依赖。2NF 要求，如果依赖于主键，则需要依赖于所有主键，不能存在依赖部分主键的情况。通俗说，就是不要把不相关的东西放到一个表中。不相关的东西不要放在一起，用多个小表连接来代替大表，减少修改时候的负担。</p>
<ul>
<li>函数依赖：若在一张表中，在属性（或属性组）X 的值确定的情况下，必定能确定属性 Y 的值，那就可以说 Y 函数依赖于 X，写作 $X\toY$。函数依赖包括三种依赖：完全函数依赖、部分函数依赖、传递函数依赖。</li>
<li>码：假设 K 为某表中的一个属性或属性组，若除 K 之外的所有属性都<strong>完全函数依赖</strong>于 K，那么我们称 K 为候选码，简称为码。换句话说，假如当 K 确定的情况下，该表除 K 之外的所有属性的值也就随之确定，那么 K 就是码。一张表中可以有超过一个码。实际应用中为了方便，通常选择其中的一个码作为主码。</li>
<li>非主属性：包含在任何一个码中的属性称为主属性。</li>
</ul>
<p>判断是否符合 2NF 就是看数据表中是否存在非主属性对于码的部分函数依赖。若存在，则数据表最高只符合 1NF 的要求，若不存在，则符合 2NF 的要求。判断方法为：</p>
<ul>
<li>第一步：找出数据表中所有的码。</li>
<li>第二步：根据第一步得到的码，找出所有的主属性。</li>
<li>第三步：数据表中，除去所有的主属性，剩下的就都是非主属性了。</li>
<li>第四步：查看是否存在非主属性对码的部分函数依赖。</li>
</ul>
<p>如何消除部分函数依赖，从而让表符合 2NF 的要求？</p>
<ul>
<li>将大数据表拆分成两个或者更多个更小的数据表，在拆分过程中，要达到更高一级范式的要求，这个过程叫做<strong>模式分解</strong>。模式分解方法不是唯一的。<strong>如何进行模式分解呢？</strong></li>
</ul>
<p>仅仅符合 2NF 的要求，仍然存在非主属性对于码的传递函数依赖。为了进一步解决问题，还需将数据表改进为符合 3NF 的要求。</p>
<p>第三范式 3NF：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖。如果存在非主属性对于码的传递函数依赖，则不符合 3NF 的要求。3NF 避免了查询路径过长而导致询问时间过长或者更新异常，提高查询效率。然而，在某些特殊情况下，即使关系模式符合 3NF 的要求，仍然存在这插入、修改、删除异常。造成问题的原因在于，存在着主属性对于码的部分函数依赖和传递函数依赖。解决办法是在 3NF 的基础上消除主属性对于码的部分与传递函数依赖。此时的设计为 BCNF 范式。BC 范式的每个表中只有一个候选键。</p>
<p><strong>所谓的范式，是用来学习参考的，设计的时候根据情况，未必一定要遵守。</strong></p>
<p>参考：</p>
<ul>
<li><a href="https://www.zhihu.com/question/24696366" target="_blank" rel="external">解释一下关系数据库的第一第二第三范式？刘慰、Lyken的回答</a></li>
</ul>
<p>拓展阅读：</p>
<ul>
<li><a href="http://www.cnblogs.com/CareySon/archive/2010/02/16/1668803.html" target="_blank" rel="external">数据库范式那些事</a></li>
</ul>
<hr>
<p>参考资料：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/23713529" target="_blank" rel="external">知乎专栏-学习编程：常见面试题整理–数据库篇</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      看到一篇不错的关于数据库面试问题的解答的知乎专栏文章，拿过来咀嚼一番，记录在此，以便后面查阅和扩充相关内容。
    
    </summary>
    
      <category term="Notes" scheme="blog.alexiangli.com/categories/Notes/"/>
    
    
      <category term="Database" scheme="blog.alexiangli.com/tags/Database/"/>
    
      <category term="SQL" scheme="blog.alexiangli.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>R：使用 tidyr 进行数据操作</title>
    <link href="blog.alexiangli.com/r-tidyr/"/>
    <id>blog.alexiangli.com/r-tidyr/</id>
    <published>2016-11-16T16:00:00.000Z</published>
    <updated>2016-11-19T03:33:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="宽转长-wide2long">宽转长 Wide2Long</h1>
<p><code>tidyr::gather(data, key, value, ..., na.rm = FALSE, convert = FALSE, factor_key = FALSE)</code></p>
<p>参数：</p>
<ul>
<li><code>data</code> 数据框</li>
<li><code>key</code> 键，新生成的因子列名（不需要加引号）</li>
<li><code>value</code> 值，新生成的数值列名（不需要加引号）</li>
<li><code>...</code> 所指定的需要转换的列，使用变量名，即原来数据框的列名。变量名将构成合并的键的因子。有以下几种表示方式：
<ul>
<li><code>x:z</code> 选择所有的 x 与 z 之间的变量（包括 x 和 z）</li>
<li><code>-z</code> 排除 z 变量</li>
<li><code>x,y,z</code> 选择 x y z 三个变量</li>
<li><code>2:4</code> 选择第2到4列</li>
</ul>
</li>
<li><code>na.rm</code> 是否去除缺失值</li>
<li><code>convert</code> 自动转换键列的值的数据类型，当需合并的列名为数值，整数，或逻辑值时非常有用</li>
<li><code>factor_key</code> 是否将键的内容转换为因子，默认为 <code>FALSE</code> 即存储为字符向量</li>
</ul>
<h1 id="长转宽-long2wide">长转宽 Long2Wide</h1>
<p><code>tidyr::spread(data, key, value, fill = NA, convert = FALSE, drop = TRUE, sep = NULL)</code></p>
<p>参数：</p>
<ul>
<li><code>key</code> 该列的因子转换为多个列的列名</li>
<li><code>value</code> 该列的内容将分配到多个列中</li>
<li><code>fill</code> 指定填充缺失值的值</li>
<li><code>convert</code> 数据类型转换</li>
<li><code>drop</code> 是否丢弃数据中不存在的因子水平，如果为 <code>FALSE</code>，那么将把没有数据的因子的值使用 <code>fill</code> 的参数值填充。</li>
<li><code>sep</code> 如果为 <code>NULL</code>，新列名为键所在的列的值；如果不为 <code>NULL</code>，列名将为 <code>&lt;key_name&gt;&lt;sep&gt;&lt;key_value&gt;</code>，即键所在的列名加上分隔字符加键所在的列的值。例如：如果 <code>key</code> 为 <code>A</code>，A 有两个因子水平，<code>A1,A2</code>，<code>sep=&quot;-&quot;</code>，那么列名将为 <code>A-A1,A-A2</code>。</li>
</ul>
<h1 id="分割单列为多列">分割单列为多列</h1>
<p><code>tidyr::separate(data, col, into, sep = &quot;[^[:alnum:]]+&quot;, remove = TRUE, convert = FALSE, extra = &quot;warn&quot;, fill = &quot;warn&quot;, ...)</code></p>
<p>参数：</p>
<ul>
<li><code>col</code> 列名（不需要引号）</li>
<li><code>into</code> 字符串向量，例如 <code>c(&quot;x&quot;, &quot;y&quot;)</code>，分隔的列的列名就是 x 和 y。</li>
<li><code>sep</code> 分隔符，取值可以为正则表达式，也可以为数值。分隔符的长度必须比 <code>into</code> 少1。
<ul>
<li>如果为字符串，那么被当作正则表达式处理。默认值为匹配任意非字母和数字的符号。</li>
<li>如果为数值，被当作分隔的位置。正数表示从第1个字符开始数，负数表示从右边第1个字符开始数。</li>
</ul>
</li>
<li><code>remove</code> 是否剔除输入列，默认为 <code>TRUE</code>，表示将 <code>col</code> 和 <code>into</code> 剔除。</li>
<li><code>convert</code> 数据类型转换。</li>
<li><code>extra</code> 如果 <code>sep</code> 为字符向量，且值太多，使用该参数控制结果
<ul>
<li><code>&quot;warn&quot;</code> 默认值，发出警告，并丢弃多余的值</li>
<li><code>&quot;drop&quot;</code> 丢弃多余的值，不发出警告</li>
<li><code>&quot;merge&quot;</code> 分割的次数为 <code>into</code> 长度数目</li>
</ul>
</li>
<li><code>fill</code> 如果 <code>sep</code> 为字符向量，且值不足，使用该参数控制结果
<ul>
<li><code>&quot;warn&quot;</code> 默认值，发出警告，从右往左填充</li>
<li><code>&quot;right&quot;</code> 在右侧填充</li>
<li><code>&quot;left&quot;</code> 在左侧填充</li>
</ul>
</li>
</ul>
<p>对于 <code>extra</code> 和 <code>fill</code> 参数不熟悉。</p>
<h1 id="合并多列为单列">合并多列为单列</h1>
<p><code>tidyr::unite(data, col, ..., sep = &quot;_&quot;, remove = TRUE)</code></p>
<p>参数：</p>
<ul>
<li><code>col</code> 将要合并得到的列名</li>
<li><code>...</code> 指定要被合并的列名，表示方式和 <code>tidyr::gather</code> 一样</li>
<li><code>sep</code> 分隔符</li>
<li><code>remove</code> 默认为 <code>TRUE</code>，删除输入列，即 <code>...</code> 中的列</li>
</ul>
<h1 id="实例">实例</h1>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">library</span>(tidyr)</div><div class="line">data.long &lt;- data.frame(</div><div class="line">  id = rep.int(c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>), <span class="number">2</span>),</div><div class="line">  key = rep(c(<span class="string">"f1"</span>,<span class="string">"f2"</span>), each = <span class="number">3</span>),</div><div class="line">  value = sample(<span class="number">6</span>, <span class="number">6</span>, replace = <span class="literal">TRUE</span>)</div><div class="line">)</div><div class="line">&gt;&gt;&gt; data.long</div><div class="line">id key value</div><div class="line"><span class="number">1</span>  <span class="number">1</span>  f1     <span class="number">4</span></div><div class="line"><span class="number">2</span>  <span class="number">2</span>  f1     <span class="number">6</span></div><div class="line"><span class="number">3</span>  <span class="number">3</span>  f1     <span class="number">5</span></div><div class="line"><span class="number">4</span>  <span class="number">1</span>  f2     <span class="number">3</span></div><div class="line"><span class="number">5</span>  <span class="number">2</span>  f2     <span class="number">6</span></div><div class="line"><span class="number">6</span>  <span class="number">3</span>  f2     <span class="number">5</span></div></pre></td></tr></table></figure>
<p>长转宽</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">data.wide &lt;- spread(data.long, key = key, value = value)</div><div class="line">&gt;&gt;&gt; data.wide</div><div class="line">id f1 f2</div><div class="line"><span class="number">1</span>  <span class="number">1</span>  <span class="number">4</span>  <span class="number">3</span></div><div class="line"><span class="number">2</span>  <span class="number">2</span>  <span class="number">6</span>  <span class="number">6</span></div><div class="line"><span class="number">3</span>  <span class="number">3</span>  <span class="number">5</span>  <span class="number">5</span></div></pre></td></tr></table></figure>
<p>宽转长</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">data.long &lt;- gather(data.wide, key = key, value = value, f1, f2)</div><div class="line"><span class="comment">## data.long &lt;- gather(data.wide, key = key, value = value, f1:f2)</span></div><div class="line"><span class="comment">## data.long &lt;- gather(data.wide, key = key, value = value, 2:3)</span></div></pre></td></tr></table></figure>
<p>合并列与分割列</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#### 新加一列</span></div><div class="line">data.long$g &lt;- rep(c(<span class="string">"g1"</span>,<span class="string">"g2"</span>), each = <span class="number">3</span>)</div><div class="line">&gt;&gt;&gt; data.long</div><div class="line">id key value  g</div><div class="line"><span class="number">1</span>  <span class="number">1</span>  f1     <span class="number">4</span> g1</div><div class="line"><span class="number">2</span>  <span class="number">2</span>  f1     <span class="number">6</span> g1</div><div class="line"><span class="number">3</span>  <span class="number">3</span>  f1     <span class="number">5</span> g1</div><div class="line"><span class="number">4</span>  <span class="number">1</span>  f2     <span class="number">3</span> g2</div><div class="line"><span class="number">5</span>  <span class="number">2</span>  f2     <span class="number">6</span> g2</div><div class="line"><span class="number">6</span>  <span class="number">3</span>  f2     <span class="number">5</span> g2</div><div class="line"></div><div class="line"><span class="comment">#### 合并 key 和 g</span></div><div class="line">data.long.unite &lt;- unite(data.long, col = grp_key, key, g, sep = <span class="string">"-"</span>)</div><div class="line">&gt;&gt;&gt; data.long.unite</div><div class="line">id grp_key value</div><div class="line"><span class="number">1</span>  <span class="number">1</span>   f1-g1     <span class="number">4</span></div><div class="line"><span class="number">2</span>  <span class="number">2</span>   f1-g1     <span class="number">6</span></div><div class="line"><span class="number">3</span>  <span class="number">3</span>   f1-g1     <span class="number">5</span></div><div class="line"><span class="number">4</span>  <span class="number">1</span>   f2-g2     <span class="number">3</span></div><div class="line"><span class="number">5</span>  <span class="number">2</span>   f2-g2     <span class="number">6</span></div><div class="line"><span class="number">6</span>  <span class="number">3</span>   f2-g2     <span class="number">5</span></div><div class="line"></div><div class="line"><span class="comment">#### 分割列为多列</span></div><div class="line">data.long.sep &lt;- separate(data.long.unite, col = grp_key, into = c(<span class="string">"key"</span>, <span class="string">"grp"</span>), sep = <span class="string">"-"</span>)</div><div class="line">&gt;&gt;&gt; data.long.sep</div><div class="line">id key grp value</div><div class="line"><span class="number">1</span>  <span class="number">1</span>  f1  g1     <span class="number">4</span></div><div class="line"><span class="number">2</span>  <span class="number">2</span>  f1  g1     <span class="number">6</span></div><div class="line"><span class="number">3</span>  <span class="number">3</span>  f1  g1     <span class="number">5</span></div><div class="line"><span class="number">4</span>  <span class="number">1</span>  f2  g2     <span class="number">3</span></div><div class="line"><span class="number">5</span>  <span class="number">2</span>  f2  g2     <span class="number">6</span></div><div class="line"><span class="number">6</span>  <span class="number">3</span>  f2  g2     <span class="number">5</span></div></pre></td></tr></table></figure>
<p>拓展阅读：</p>
<ul>
<li><a href="https://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html" target="_blank" rel="external">Hadley Wickham: Tidy data</a></li>
<li><a href="https://rpubs.com/bradleyboehmke/data_wrangling" target="_blank" rel="external">Brad Boehmke: Data Processing with dplyr &amp; tidyr</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;宽转长-wide2long&quot;&gt;宽转长 Wide2Long&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;tidyr::gather(data, key, value, ..., na.rm = FALSE, convert = FALSE, factor_key = FALSE)&lt;
    
    </summary>
    
      <category term="Original" scheme="blog.alexiangli.com/categories/Original/"/>
    
    
      <category term="R" scheme="blog.alexiangli.com/tags/R/"/>
    
      <category term="tidyr" scheme="blog.alexiangli.com/tags/tidyr/"/>
    
  </entry>
  
  <entry>
    <title>R：使用基本包进行多图布局</title>
    <link href="blog.alexiangli.com/r-vis-layout/"/>
    <id>blog.alexiangli.com/r-vis-layout/</id>
    <published>2016-11-15T16:00:00.000Z</published>
    <updated>2016-12-03T13:32:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="layout-布局">Layout 布局</h1>
<p><code>layout</code> 函数可以指定复杂的绘图布局。该函数可以将设备的面板根据第一个参数 <code>mat</code> 矩阵分割为多个行和列，列宽和行高在对应的参数中指定。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">layout(mat, widths = rep.int(<span class="number">1</span>, ncol(mat)),</div><div class="line">    heights = rep.int(<span class="number">1</span>, nrow(mat)),</div><div class="line">    respect = <span class="literal">FALSE</span>)</div></pre></td></tr></table></figure>
<p><code>layout.show(n)</code> 显示当前布局。<code>n</code> 为显示的图形的个数。<code>n=1</code> 则显示第一个图形的布局，<code>n=2</code> 则显示前两个图形的布局。<br>
<code>layout</code> 返回的值为图形的个数。</p>
<p>参数：</p>
<ul>
<li><code>mat</code>：矩阵对象，指定接下来的 N 个图形的位置。矩阵中的值必须为 0 或者正整数。</li>
<li><code>widths</code>：向量对象，指定列宽。可以通过数值指定相对宽度。而绝对宽度通过 <code>lcm()</code> 指定。</li>
<li><code>heights</code>：向量对象，指定列高。高度设置跟 <code>widths</code> 一样。</li>
<li><code>respect</code>：要么逻辑值要么矩阵对象。如果为矩阵对象，那么必须与 <code>mat</code> 具有同样的维度，而且每个值为 0 或者 1。该参数控制列宽的单位是否与行高的单位在设备物理测量上相同，控制设备的纵横比。纵横比为列数比上行数。如果 <code>respect = TRUE</code> 那么列宽和行高单位相同，不受页面纵横比的影响。如果 <code>respect = FALSE</code>，那么一行的高和一列的宽不一样，会受到页面的影响。</li>
<li><code>n</code>：绘制的图形个数。</li>
</ul>
<p>需要注意的是，<code>layout</code> 布局与 <code>par(mfrow)</code> <code>par(mfcol)</code> <code>split.screen</code> 完全不兼容。</p>
<h1 id="par-的-mfrow-和-mfcol-参数布局">Par 的 mfrow 和 mfcol 参数布局</h1>
<p><code>par</code> 用于设置或查询绘图参数。<code>par</code> 的合法参数都能在高阶绘图函数中使用。<br>
在 <code>par</code> 的众多参数中，有两个参数可以用于多图的布局，即 <code>mfrow</code> 和 <code>mfcol</code>。</p>
<h2 id="par-关于布局的参数">par 关于布局的参数</h2>
<p><strong>Outer margin</strong> 外边缘</p>
<p>默认没有外边缘。可以通过 <code>oma</code> 增加外边缘，其单位为线宽，即一行文字的空间。还有 <code>omi</code> 和 <code>omd</code> 设置外边缘宽度，单位分别为英寸和 NDC 归一化坐标。</p>
<ul>
<li><code>oma</code> 向量 <code>c(bottom, left, top, right)</code>，外边缘尺寸，行高</li>
<li><code>omd</code> 向量 <code>c(x1,x2,y1,y2)</code> 外边缘定位，单位为 NDC，即<code>c(left,right,bottom,top)</code></li>
<li><code>omi</code> 向量 <code>c(bottm, left, top, right)</code> 外边缘尺寸，英寸</li>
</ul>
<p><strong>Inner region</strong> 内区域</p>
<p>为除去外边缘之外剩余的区域。如果只有一个图，那么就等于 figure region。如果有多个图，那就是多个图合并的区域。</p>
<p><strong>Figure region</strong> 图形区域</p>
<p>受到外边缘和图的个数的影响。绘图区域通过 <code>fig</code> 和 <code>fin</code> 参数设定。<code>fig</code> 用来定位，<code>c(left, right, bottom, top)</code>，其中的值为内区域的大小（除去外边缘之后的区域）。<code>fin</code> 用于设定绘图区域大小，<code>c(width,height)</code>，单位为英寸，最后绘图区域将在内区域中居中。</p>
<p><strong>Figure margin</strong> 图形边缘</p>
<p>图形边缘，通过 <code>mar</code> 和 <code>mai</code> 参数设定。</p>
<ul>
<li><code>mai</code> 数值向量 <code>c(bottom, left, top, right)</code> 绘图边缘的尺寸，英寸</li>
<li><code>mar</code> 数值向量 <code>c(bottom, left, top, right)</code> 指定绘图边缘尺寸，行高，默认为 <code>c(5,4,4,2)+0.1</code></li>
<li><code>mex</code> 行尺寸扩展因子，用于描述绘图边缘上的坐标。并不改变字体大小，而是指定用来转换 <code>mar</code> 和 <code>mai</code> 以及 <code>oma</code> 和 <code>omi</code> 的文本行尺寸。</li>
<li><code>mgp</code> 边缘行（<code>mex</code> 单位），用于轴标题、标签和线。<code>mgp[1]</code> 影响 <code>title</code>,<code>mgp[2:3]</code> 影响坐标轴。默认为 <code>c(3,1,0)</code>。</li>
</ul>
<p><strong>Plot region</strong> 绘制区域</p>
<ul>
<li><code>plt</code> 向量 <code>c(x1,x2,y1,y2)</code> 图形区域的坐标 (left, right, bottom, top)</li>
<li><code>ply</code> 字符，指定图形区域类型，<code>&quot;s&quot;</code> 为正方形绘图区域，<code>&quot;m&quot;</code> 为最大绘图区域。</li>
<li><code>pin</code> 尺寸，<code>c(width, height)</code></li>
</ul>
<p>子图或多图绘制</p>
<ul>
<li><code>mfcol, mfrow</code> 向量 <code>c(nr, nc)</code>，绘制 nr*nc 子图矩阵。</li>
<li><code>mfg</code> 向量 <code>c(i,j)</code> 表示接下来图形绘制的位置。必须实现定义好 <code>mfcol</code> 或者 <code>mfow</code>。另外，为了兼容 <code>S</code> 语言，还可以以 <code>c(i,j,nr,nc)</code> 的形式指定位置。</li>
</ul>
<h1 id="split-screen-布局">Split.screen 布局</h1>
<p><code>split.screen</code> 定义在当前设备上一定数量的区域，可以在一定程度上当作独立/分离的图形设备。<br>
<code>screen</code> 用于选择哪一个 screen 绘制图形。<br>
<code>erase.screen</code> 用于清除一个 screen，通过填充背景颜色。<br>
<code>close.screen</code> 移除指定的 screen。</p>
<p><code>split.screen</code> 参数：</p>
<ul>
<li><code>figs</code> 两个元素的向量，描述了在一个屏幕矩阵中的行和列的数目，或者一个4列矩阵。如果是矩阵，那么每一行描述了一个屏幕的左、右、下和上端的值，为 NDC 单位，即0为最左下角，1为最右上角。</li>
<li><code>screen</code> 用于分割的屏幕编号。默认为当前屏幕，否则为整个设备区域。</li>
<li><code>erase</code> 逻辑值，是否清空选中的屏幕。</li>
<li><code>n</code> 代表将准备用于绘制、擦除、或者关闭的屏幕编号。</li>
<li><code>new</code> 逻辑值，代表着是否擦除当前屏幕用于新图的绘制。</li>
<li><code>all.screens</code> 逻辑值，是否关闭所有屏幕。</li>
</ul>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">split.screen(c(<span class="number">2</span>,<span class="number">2</span>)) <span class="comment"># 构建两行两列的 screen</span></div><div class="line">screen(<span class="number">2</span>) <span class="comment"># 选中第2个 screen</span></div><div class="line">split.screen(c(<span class="number">2</span>,<span class="number">1</span>)) <span class="comment"># 将第2个 screen 再次分割为两行</span></div><div class="line">screen(<span class="number">4</span>) <span class="comment"># 选中第4个 screen</span></div><div class="line">plot(<span class="number">10</span>:<span class="number">1</span>)</div><div class="line">erase.screen() <span class="comment"># 擦除当前 screen</span></div><div class="line">plot(<span class="number">15</span>:<span class="number">1</span>) <span class="comment"># 继续在当前 screen 上绘制</span></div></pre></td></tr></table></figure>
<p>NDC：normalized device coordinates</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;layout-布局&quot;&gt;Layout 布局&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;layout&lt;/code&gt; 函数可以指定复杂的绘图布局。该函数可以将设备的面板根据第一个参数 &lt;code&gt;mat&lt;/code&gt; 矩阵分割为多个行和列，列宽和行高在对应的参数中指定。&lt;/p&gt;
&lt;f
    
    </summary>
    
      <category term="Original" scheme="blog.alexiangli.com/categories/Original/"/>
    
    
      <category term="R" scheme="blog.alexiangli.com/tags/R/"/>
    
      <category term="Data viz" scheme="blog.alexiangli.com/tags/Data-viz/"/>
    
  </entry>
  
  <entry>
    <title>实验室内部分享一：绘制和编辑可发表的图形</title>
    <link href="blog.alexiangli.com/image-output/"/>
    <id>blog.alexiangli.com/image-output/</id>
    <published>2016-11-13T16:00:00.000Z</published>
    <updated>2016-11-19T03:32:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文为实验室内部分享内容提纲。<br>
分享目的：做到在不求人的情况下无痛高效地输出符合论文投稿要求的图形。</p>
<h1 id="准备知识">准备知识</h1>
<h2 id="颜色模式">颜色模式</h2>
<ul>
<li>印刷：CMYK，印刷三原色（青品黄），叠加变暗 —&gt; 打印出版</li>
<li>显示：RGB，光影三原色（黄绿蓝），叠加变亮 —&gt; 在线出版</li>
<li>其他：HSB, Lab, 位图模式，灰度模式，索引颜色模式，双色模式，多通道模式等</li>
</ul>
<h2 id="图形格式">图形格式</h2>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">定义</th>
<th style="text-align:left">特点</th>
<th style="text-align:left">常见格式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">矢量图</td>
<td style="text-align:left">使用点、线、面（多边形）等基于数学方程的几何图元表示的图像</td>
<td style="text-align:left">放大缩小图形质量不变</td>
<td style="text-align:left">eps, svg, pdf, …</td>
</tr>
<tr>
<td style="text-align:left">位图</td>
<td style="text-align:left">使用像素阵列表示的图像</td>
<td style="text-align:left">尺寸放大会影响质量</td>
<td style="text-align:left">jpg, png, tiff, …</td>
</tr>
</tbody>
</table>
<h2 id="图形分辨率">图形分辨率</h2>
<p>分辨率：两侧或者显示系统对细节的分辨能力。<br>
PPI/DPI 单位：表示打印图像或显示器单位面积上像素/点数量的指数。</p>
<p>PPI</p>
<ul>
<li>每英寸像素数</li>
<li>用于电脑显示领域</li>
<li>人类肉眼能够分辨的最高像素点密度为 300ppi</li>
</ul>
<p>DPI</p>
<ul>
<li>每英寸点数</li>
<li>用于打印或印刷领域</li>
</ul>
<h1 id="图形编辑软件使用">图形编辑软件使用</h1>
<ul>
<li>Adobe Illustrator 商业矢量图编辑软件：<strong>主要内容</strong></li>
<li>Adobe Photoshop 商业位图编辑软件</li>
<li>Inkscape 免费开源矢量图编辑软件</li>
</ul>
<h2 id="基本界面">基本界面</h2>
<ul>
<li>菜单栏</li>
<li>工具栏</li>
<li>控制面板</li>
<li>图形窗口</li>
</ul>
<h2 id="快捷键">快捷键</h2>
<ul>
<li>工具选择快捷键：快速切换当前工具</li>
<li>组合快捷键：快速操作对象，选择功能等</li>
</ul>
<h2 id="常用工具与概念">常用工具与概念</h2>
<h3 id="对象">对象</h3>
<ul>
<li>对象：具有一定属性的点，线，面（填充）等</li>
<li>对象的基本操作：移动，旋转，镜像，拷贝 …</li>
<li>建立组与取消组：建立组方便对整体进行操作。</li>
</ul>
<h3 id="选择">选择</h3>
<ul>
<li>一般选择与直接选择（组选择）</li>
<li>相似对象选择：选择文本对象，选择单独的点，…</li>
<li>相似属性选择：选择具有相同描边的对象，选择具有相同填充的对象，…</li>
</ul>
<h3 id="图层">图层</h3>
<ul>
<li>操作图层：删除，新建，隐藏，锁定</li>
<li>管理图层：移动，合并，重命名</li>
</ul>
<h3 id="其他重要操作">其他重要操作</h3>
<ul>
<li>路径查找：Window &gt;&gt;&gt; Pathfinder</li>
<li>排列对齐：Window &gt;&gt;&gt; Align</li>
<li>字体描边：Type &gt;&gt;&gt; Create Outline</li>
<li>取色：工具栏 &gt;&gt;&gt; Eye droper tool</li>
<li>属性修改（线）：Window &gt;&gt;&gt; Appearance</li>
</ul>
<h1 id="实例">实例</h1>
<ol>
<li>实验流程图</li>
<li>单图编辑</li>
<li>多图合并</li>
<li>ERP 线图编辑</li>
<li>…</li>
</ol>
<h1 id="绘制图表">绘制图表</h1>
<ul>
<li>编程语言：R, Python, Matlab, … &gt;&gt;&gt; 推荐学习</li>
<li>界面操作：Excel, SPSS, JASP, …</li>
<li>在线绘制：<a href="http://plot.ly" target="_blank" rel="external">plot.ly</a>, …</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为实验室内部分享内容提纲。&lt;br&gt;
分享目的：做到在不求人的情况下无痛高效地输出符合论文投稿要求的图形。&lt;/p&gt;
&lt;h1 id=&quot;准备知识&quot;&gt;准备知识&lt;/h1&gt;
&lt;h2 id=&quot;颜色模式&quot;&gt;颜色模式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;印刷：CMYK，印刷三原色（青品黄），叠加
    
    </summary>
    
      <category term="Original" scheme="blog.alexiangli.com/categories/Original/"/>
    
    
      <category term="学术出版" scheme="blog.alexiangli.com/tags/%E5%AD%A6%E6%9C%AF%E5%87%BA%E7%89%88/"/>
    
      <category term="统计图表" scheme="blog.alexiangli.com/tags/%E7%BB%9F%E8%AE%A1%E5%9B%BE%E8%A1%A8/"/>
    
      <category term="Illustrator" scheme="blog.alexiangli.com/tags/Illustrator/"/>
    
      <category term="Photoshop" scheme="blog.alexiangli.com/tags/Photoshop/"/>
    
      <category term="Inkscape" scheme="blog.alexiangli.com/tags/Inkscape/"/>
    
      <category term="矢量图" scheme="blog.alexiangli.com/tags/%E7%9F%A2%E9%87%8F%E5%9B%BE/"/>
    
      <category term="位图" scheme="blog.alexiangli.com/tags/%E4%BD%8D%E5%9B%BE/"/>
    
      <category term="Lab" scheme="blog.alexiangli.com/tags/Lab/"/>
    
  </entry>
  
  <entry>
    <title>男士衬衫穿搭技巧</title>
    <link href="blog.alexiangli.com/life-shirt/"/>
    <id>blog.alexiangli.com/life-shirt/</id>
    <published>2016-11-10T16:00:00.000Z</published>
    <updated>2016-11-19T03:31:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>临近求职，即将从学生狗迈入“社会”，需要关注下着装和生活品味。个人喜欢将看起来不严肃的事情也当做很“正经”的事情学习研究一番，这篇笔记便是最好的见证。</p>
<h1 id="男士衬衫穿搭技巧">男士衬衫穿搭技巧</h1>
<h2 id="正装衬衫">正装衬衫</h2>
<h3 id="挑选技巧">挑选技巧</h3>
<ol>
<li>合身：首要条件务必合身。</li>
<li>版型：</li>
</ol>
<ul>
<li><strong>Slim</strong> 腰线挺拔</li>
<li><strong>Regular</strong> 严肃商务风</li>
<li><strong>Full</strong> 宽容，适合较胖的人</li>
</ul>
<ol start="3">
<li>颜色：白色严肃，适合最正式及重要场合；次重要场合可以选蓝色和灰色。</li>
</ol>
<h3 id="搭配技巧">搭配技巧</h3>
<ol>
<li>白衬衫谨慎单穿：对身材要求高；故可做正装内搭；单穿宜选择蓝灰。</li>
<li>搭配灰色或海军蓝的西装：黑色适合场合较少，比较沉闷和老气。</li>
<li>正装衬衫也可以在非正式场合穿：例如，搭配不沉闷的领带。也可以把休闲商务内搭换成正装衬衫。</li>
</ol>
<h2 id="牛津纺衬衫">牛津纺衬衫</h2>
<blockquote>
<p>牛津纺一般由白色和其他颜色的纱线交织而成。白色的加入，会在视觉上弱化了另一颜色的色度，形成的特殊“点状肌理”，使整体的色调更加柔和，这也是牛津纺最吸引人之处。<br>
牛津纺衬衫的适用性非常强，既可上班，亦可休闲，并往往能体现穿着者儒雅、斯文的一面。</p>
</blockquote>
<h3 id="搭配技巧-v2">搭配技巧</h3>
<ol>
<li>衬衫下摆处理：牛津纺适合单穿，在不同场合可以考虑是否将下摆包进裤子里。
<ul>
<li>日常工作场合，可以考虑穿着蓝色、灰色等明度低的牛津纺衬衫，下摆包进裤子。可搭配一条卡其裤/西裤，和一双与之搭配的鞋子。</li>
<li>工作之余下摆可以不用包进裤子，但这种情况下，下摆不宜过长。合适的下摆有利于调整身材比例。</li>
</ul>
</li>
<li>牛津纺色调较柔和，可以尝试多种颜色：白蓝为百搭；粉红色适合偏瘦的人；马卡龙绿、桃红适合沙滩、度假等休闲场合。</li>
<li>无敌内搭单品：虽百搭，但与之绝配的是针织衫/毛衣。还可以搭配外套或夹克。</li>
</ol>
<h2 id="格子衬衫">格子衬衫</h2>
<h3 id="挑选原则">挑选原则</h3>
<ol>
<li>小格子：大格子衬衫是屌丝感的罪魁祸首。</li>
<li>颜色鲜而柔和</li>
</ol>
<blockquote>
<p>小格子可以穿出文艺温柔的感觉，鲜亮而柔和的颜色避免了深色线条的粗硬感；另外小格子衬衫可把扣子全扣上穿出一种精致感。</p>
</blockquote>
<h3 id="搭配技巧-v3">搭配技巧</h3>
<p>格子衬衫单穿对衬衫及个人气质要求相对高，但内搭比较容易穿出彩。</p>
<p>格子衬衫搭配需要遵循2个原则：</p>
<ol>
<li>同色系：搭配的其他单品最好呼应其中的颜色，而不要给造型新增颜色。</li>
<li>简约（Simple）：搭配单品尽量保持 simple（纯色、无花纹）</li>
</ol>
<p>技巧：</p>
<ol>
<li>内搭纯白 Tee：选择跟格子颜色相关的裤子。</li>
<li>绑在腰上，作为造型装饰。</li>
<li>内搭：西装、马甲、皮衣都非常合适。
<ul>
<li>西装：可不需要格子衬衫与西装色系呼应，可以大胆撞色。</li>
<li>马甲：化解了单穿格子衬衫的难度。</li>
</ul>
</li>
<li>如何化解深色大格子衬衫的屌丝既视感：搭配牛仔外套，将衬衫内搭，其他单品遵循同色系、simple两个原则。</li>
</ol>
<h2 id="牛仔衬衫">牛仔衬衫</h2>
<p>牛仔衬衫包括两种风格：</p>
<ol>
<li>阳刚不羁：牛仔布厚实、织纹清晰，加上洗水工艺</li>
<li>优雅清新：牛仔布细密柔软，水洗致颜色柔和</li>
</ol>
<h3 id="搭配技巧-v4">搭配技巧</h3>
<ol>
<li>单穿、外穿牛仔衬衫：让牛仔衬衫成为主角！
<ul>
<li>下身可搭配深色牛仔裤、卡其裤、中长靴；</li>
<li>避免同牛仔衬衫颜色接近的牛仔裤；</li>
</ul>
</li>
<li>内搭：可搭配棒球外套、皮衣和针织衫。</li>
<li>搭配军绿色单品：军绿色风格与天然有着硬朗感的牛仔衬衫风格匹配。</li>
</ol>
<h2 id="个人总结">个人总结</h2>
<ul>
<li>正式场合颜色和面料宜淡雅</li>
<li>分清主配角</li>
<li>灵活运用加减法</li>
<li>一定要考虑身材和场合</li>
<li>正装衬衫可以和休闲单品搭配，但休闲款谨慎当正装穿</li>
<li>你柔我柔，你刚我刚</li>
<li>没有完美的单品，单穿还是内外搭，需具体分析</li>
</ul>
<hr>
<p>该博文总结浓缩于<a href="https://www.douban.com/note/513750015/" target="_blank" rel="external">这篇文章</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;临近求职，即将从学生狗迈入“社会”，需要关注下着装和生活品味。个人喜欢将看起来不严肃的事情也当做很“正经”的事情学习研究一番，这篇笔记便是最好的见证。&lt;/p&gt;
&lt;h1 id=&quot;男士衬衫穿搭技巧&quot;&gt;男士衬衫穿搭技巧&lt;/h1&gt;
&lt;h2 id=&quot;正装衬衫&quot;&gt;正装衬衫&lt;/h2&gt;
&lt;
    
    </summary>
    
      <category term="Notes" scheme="blog.alexiangli.com/categories/Notes/"/>
    
    
      <category term="Life style" scheme="blog.alexiangli.com/tags/Life-style/"/>
    
      <category term="Shirt" scheme="blog.alexiangli.com/tags/Shirt/"/>
    
  </entry>
  
  <entry>
    <title>R：处理缺失值</title>
    <link href="blog.alexiangli.com/r-mising-value-outlier/"/>
    <id>blog.alexiangli.com/r-mising-value-outlier/</id>
    <published>2016-11-08T16:00:00.000Z</published>
    <updated>2016-11-19T03:31:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于最近在分析毕业论文数据，顺便复习和学习新的数据分析方法，本文纯属搬运和整理他人的分享。</p>
<h1 id="缺失值处理">缺失值处理</h1>
<p><code>mice</code> 包是专门用来处理缺失值的 R 语言包。可以通过 <code>mice::md.pattern()</code> 查看缺失值的“数据模式”。</p>
<h2 id="删除记录-样本">删除记录/样本</h2>
<p>在 R 中，通过 <code>na.action = na.omit</code> 删除包含有缺失值的观测行。但需要满足两个条件：</p>
<ul>
<li>有足够的样本点；</li>
<li>不会引入偏差。</li>
</ul>
<h2 id="删除变量-属性">删除变量/属性</h2>
<p>如果数据集中某个特定变量包含较多的缺失值，并且删除这个变量能够保留更多的观测值。如果该变量不太重要，那么可以删除它。该方法需要权衡变量的重要性和观测值数量。</p>
<h2 id="使用均值-中位数-众数进行插补">使用均值/中位数/众数进行插补</h2>
<p>这是一种比较简单粗暴的方法，如果该变量对因变量的影响较小，该方法是可以接受的。但是，很可能人为增加噪音。</p>
<h2 id="预测法">预测法</h2>
<p>可使用的方法包括：KNN差值，rpart包，mice包。</p>
<h3 id="knn-差值法">kNN 差值法</h3>
<p><code>DMwR::knnImputation()</code> 函数使用 k 近邻方法来填充缺失值。</p>
<blockquote>
<p>具体过程如下：对于需要插值的记录，基于欧氏距离计算k个和它最近的观测。接着将这k个近邻的数据利用距离逆加权算出填充值，最后用该值替代缺失值。</p>
</blockquote>
<h3 id="rpart">rpart</h3>
<p>kNN 插值法的缺点对因子类变量的插补效果不好。rpart 的优点是只需一个未缺失值就可以填充整个数据样本。</p>
<h3 id="mice">mice</h3>
<blockquote>
<p>mice 是链式方程多元插值的简写（Multivariate Imputation by Chained Equations）。mice包提供了多种先进的缺失值处理方法。它使用一种不同寻常的方法来进行两步插值：首先利用mice函数建模再用complete函数生成完整数据。mice(df)会返回df的多个完整副本，每个副本都对缺失的数据插补了不同的值。complete()函数则会返回这些数据集中的一个（默认）或多个。</p>
</blockquote>
<p>参考资料：</p>
<ul>
<li><a href="http://www.xueqing.tv/cms/article/185" target="_blank" rel="external">雪晴数据网：R语言处理缺失值的若干方法</a><a href="http://datascienceplus.com/missing-value-treatment/" target="_blank" rel="external">原文</a></li>
<li><a href="http://datascienceplus.com/imputing-missing-data-with-r-mice-package/" target="_blank" rel="external">datascience+: Imputing Missing Data with R; MICE package</a></li>
<li><a href="http://www.zhaokv.com/2016/01/missing-values.html" target="_blank" rel="external">如何处理数据中的缺失值</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于最近在分析毕业论文数据，顺便复习和学习新的数据分析方法，本文纯属搬运和整理他人的分享。&lt;/p&gt;
&lt;h1 id=&quot;缺失值处理&quot;&gt;缺失值处理&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;mice&lt;/code&gt; 包是专门用来处理缺失值的 R 语言包。可以通过 &lt;code&gt;mice::md.p
    
    </summary>
    
      <category term="Notes" scheme="blog.alexiangli.com/categories/Notes/"/>
    
    
      <category term="R" scheme="blog.alexiangli.com/tags/R/"/>
    
      <category term="Statistics" scheme="blog.alexiangli.com/tags/Statistics/"/>
    
      <category term="数据分析" scheme="blog.alexiangli.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
      <category term="缺失值" scheme="blog.alexiangli.com/tags/%E7%BC%BA%E5%A4%B1%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>R：基本数据可视化</title>
    <link href="blog.alexiangli.com/r-basic-vis/"/>
    <id>blog.alexiangli.com/r-basic-vis/</id>
    <published>2016-11-07T16:00:00.000Z</published>
    <updated>2016-11-19T03:30:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近需要分析毕业论文数据，借机温习一下常见的统计图形，并且熟悉下如何在 R 下进行数据可视化。</p>
<h1 id="箱图-boxplot">箱图 Boxplot</h1>
<h2 id="什么是箱图？">什么是箱图？</h2>
<p>箱形图，又叫箱须图（Box-Whisker Plot），是利用数据的五个特征值来描述数据的图形。这五个特征值为：最小值、第一四分位数、中位数、第三四分位数、最大值。</p>
<h2 id="箱形图的用处">箱形图的用处</h2>
<ul>
<li>粗略估计数据的<strong>对称性</strong>：由上下箱须和箱高度的长短差异表现出来</li>
<li>粗略观察数据的<strong>离散程度</strong>和<strong>集中程度</strong>：由上下箱须距离和箱的高度表现出来</li>
<li>粗略比较样本之间的特征</li>
</ul>
<h2 id="箱形图的不足">箱形图的不足</h2>
<ul>
<li>无法精确度量数据分布的偏态和尾重程度：可通过偏态值</li>
<li>对于较大的数据集，反映的信息较为模糊</li>
<li>中位数代表总体集中程度存在局限性</li>
</ul>
<h2 id="绘制过程">绘制过程</h2>
<p><img src="/img/boxplot.jpg" alt="箱形图"></p>
<ul>
<li>计算上四分位数，中位数，下四分位数。</li>
<li>计算上四分位数和下四分位数之间的差值，即四分位数差（IQR，interquantile range）。</li>
<li>绘制箱线图的上下范围，上限为上四分位数，下限为下四分位数。在箱子内部中位数的位置绘制横线。</li>
<li>大于上四分位数1.5倍四分位数差的值，或者小于下四分位数1.5倍四分位数差的值，划为异常值（outliers）。</li>
<li>异常值之外，最靠近上边缘和下边缘的两个值处，画横线，作为箱线图的触须。</li>
<li>极端异常值，即超出四分位数差3倍距离的异常值，用实心点表示；较为温和的异常值，即处于1.5倍-3倍四分位数差之间的异常值，用空心点表示。</li>
<li>为箱线图添加名称，数轴等。</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="http://blog.sciencenet.cn/blog-255662-239993.html" target="_blank" rel="external">科学网：什么是箱线图</a></li>
<li><a href="http://web.pdx.edu/~stipakb/download/PA551/boxplot.html" target="_blank" rel="external">http://web.pdx.edu/~stipakb/download/PA551/boxplot.html</a></li>
</ul>
<h2 id="使用-r-绘制箱图">使用 R 绘制箱图</h2>
<h3 id="基本包函数-boxplot">基本包函数 <code>boxplot</code></h3>
<p>基本用法：<code>boxplot(x)</code> 或者 <code>boxplot(x~y, data)</code></p>
<p>常用参数：</p>
<ul>
<li><code>formula</code> <code>y ~ grp</code> <code>y</code> 为数值型向量，<code>grp</code> 为组或者因素水平。</li>
<li><code>range</code> 设定箱须的长度，默认为 1.5 个箱高，即 1.5 倍四分位数差。</li>
<li><code>width</code></li>
<li><code>varwidth</code></li>
<li><code>notch</code></li>
<li><code>outline</code> 是否绘制异常值</li>
<li><code>names</code> 组标签</li>
<li><code>boxwex</code> 缩放参数</li>
<li><code>staplewex</code> 须顶端的横线的宽度（按盒宽比例）</li>
<li><code>outwex</code></li>
<li><code>border</code> 边框颜色</li>
<li><code>col</code> 箱体的颜色</li>
<li><code>log</code> 对数坐标</li>
<li><code>pars</code> 更多绘图参数列表</li>
<li><code>add</code> 添加到当前图中</li>
<li><code>at</code> 绘制的位置</li>
</ul>
<h3 id="ggplot2">ggplot2</h3>
<p><code>ggplot</code> 的绘图语法是以添加图层的形式绘制图形。虽然语法上与 <code>boxplot()</code> 存在差异，但是参数都几乎一样。</p>
<p>首先通过 <code>ggplot()</code> 创建图形（初始化一个 ggplot 的对象），声明输入数据和一般的图形视觉参数（aesthetic mapping，例如线形，颜色等）：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">box_plot &lt;- ggplot(data, aes(x, y, <span class="keyword">...</span>))</div></pre></td></tr></table></figure>
<p>然后添加 <code>geom_boxplot</code> 图层（layers）：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">box_plot &lt;- box_plot + geom_boxplot(<span class="keyword">...</span>)</div></pre></td></tr></table></figure>
<p><code>geom_boxplot()</code> 函数有以下一些参数：</p>
<ul>
<li><code>mapping</code> 和 <code>data</code> 跟 <code>ggplot()</code> 的一样，当没有声明时，直接继承 <code>ggplot</code>。</li>
<li>位置：<code>position</code></li>
<li>设置异常值的样式：<code>outlier.colour</code> <code>outlier.shape</code> <code>outlier.size</code> <code>outlier.stroke</code></li>
<li>槽的样式：<code>notch</code> <code>notchwidth</code></li>
<li><code>show.legend</code> 显示图例</li>
<li><code>coef</code> 等同于 <code>boxplot</code> 中的 <code>range</code></li>
</ul>
<h3 id="lattice">lattice</h3>
<blockquote>
<p>The lattice package, written by Deepayan Sarkar, attempts to improve on base R graphics by providing better defaults and the ability to easily display multivariate relationships. In particular, the package supports the creation of trellis graphs - graphs that display a variable or the relationship between variables, conditioned on one or more other variables.</p>
</blockquote>
<p><code>lattice</code> 的特长在于展示多变量关系。</p>
<p>变量的关系通过 <code>formula</code> 表示，例如：</p>
<ul>
<li><code>~x|A</code> 表示在因素 <code>A</code> 的所有水平下绘制相应的数值变量 <code>x</code> 的图形</li>
<li><code>y~x | A*B</code> <code>A</code> 和 <code>B</code> 两个因素混合条件下的 <code>y</code> 和 <code>x</code> 的关系</li>
</ul>
<p>参考 <a href="http://www.statmethods.net/advgraphs/trellis.html" target="_blank" rel="external">Quick-R: Lattice Graphs</a></p>
<p><code>lattice</code> 中绘制箱图的函数为 <code>bwplot()</code></p>
<h2 id="与箱图类似的图">与箱图类似的图</h2>
<ul>
<li>Violin Plots <code>vioplot</code> 包
<ul>
<li>呈现出了分布特征</li>
</ul>
</li>
<li>Tufte boxplot</li>
</ul>
<h1 id="散点图-scatterplot">散点图 Scatterplot</h1>
<h2 id="什么是散点图？">什么是散点图？</h2>
<blockquote>
<p>散点图对于绘制多变量数据非常有用。它们可帮助您确定各刻度变量之间的潜在关系。简单散点图使用二维坐标系绘制两个变量。三维散点图使用三维坐标系绘制三个变量。如果需要绘制更多的变量，则可以尝试重叠散点图和散点图矩阵 (SPLOM)。重叠散点图显示 x-y 变量的重叠对，其中每一对都以颜色或形状加以区分。SPLOM 创建一个二维散点图的矩阵，在 SPLOM 中每个变量都参照另外一个变量进行绘制。</p>
</blockquote>
<ul>
<li>保留了原始数据信息</li>
<li>展示多变量关系</li>
</ul>
<h2 id="在-r-中绘制基本的散点图">在 R 中绘制基本的散点图</h2>
<ul>
<li>基本包 <code>plot</code> 顶层绘图函数：<code>plot(x, type=&quot;p&quot;, pch=1)</code></li>
<li><code>ggplot2::geom_point()</code></li>
</ul>
<h2 id="散点图矩阵">散点图矩阵</h2>
<blockquote>
<p>散点图矩阵是散点图的高维扩展，它从一定程度上克服了在平面上展示高维数据的困难，在展示多维数据的两两关系时有着不可替代的作用。— <a href="http://cos.name/2009/03/scatterplot-matrix-visualization/" target="_blank" rel="external">统计之都</a></p>
</blockquote>
<ul>
<li><code>graphics::pairs()</code> 是 R 中绘制散点图矩阵的经典函数</li>
<li><code>car::scatterplot.matrix()</code> 或者简写 <code>car::spm()</code>：可以直接指定散点图中主对角线上的绘图元素（密度图、箱线图、直方图、QQ图等）。</li>
<li><code>YaleToolkit::gpairs()</code></li>
<li><code>lattice::splom()</code> 可以按类别绘制散点图矩阵。</li>
<li><code>GGally::ggpairs()</code> Hadley 推荐的绘制散点图矩阵的函数，用于替代 <code>ggplot2::plotmatrix()</code></li>
</ul>
<h2 id="散点图变式或类似的图形">散点图变式或类似的图形</h2>
<p>热图</p>
<ul>
<li><code>gplots::heatmap.2()</code></li>
<li><code>ggplot2::geom_raster()</code> <code>ggplot2::geom_tile()</code></li>
</ul>
<p>hexbin plot</p>
<blockquote>
<p>We can use the hexbin package in case we have multiple points in the same place (overplotting). Hexagon binning is a form of bivariate histogram useful for visualizing the structure in datasets with large n.</p>
</blockquote>
<ul>
<li>
<p><code>Hexbin::hexbinplot()</code></p>
</li>
<li>
<p><code>ggplot2</code>: <code>stat_binhex()</code> <code>geom_bin2d()</code></p>
</li>
<li>
<p>在散点图上添加等高线：<code>ggplot2::geom_density2d()</code></p>
</li>
<li>
<p>对散点图进行平滑 <code>graphics::smoothScatter()</code></p>
</li>
<li>
<p>在散点图上加上分布图或者直方图</p>
<ul>
<li>使用 <code>ggplot2</code> 分别绘制散点图和直方图，然后用 <code>gridExtra</code> 把图拼接在一起。</li>
<li>使用 <code>ggplot2</code> 中的 <code>geom_rug()</code> 图层（rug plots）</li>
<li>使用 <code>ggExtra::ggMarginal()</code> 添加直方图到 <code>ggplot</code> 图层上。</li>
<li>在这里可能需要对齐图，可以用到 <code>gtable</code> 包，可以将不同的 <code>ggplot</code> 图拼接时对齐。</li>
</ul>
</li>
</ul>
<p>参考: <a href="http://stackoverflow.com/questions/7714677/r-scatterplot-with-too-many-points" target="_blank" rel="external">StackOverflow: Scatterplot with too many points</a></p>
<h1 id="直方图-histogram">直方图 Histogram</h1>
<p>直方图用来展示数值型数据的分布，可以用来估计连续性数据的概率分布。直方图的纵轴为频率或者相对频率。</p>
<p>使用 R 绘制直方图：</p>
<p><code>graphics::hist()</code><br>
<code>graphics::plot.histogram()</code><br>
<code>lattice::histogram()</code><br>
<code>MASS::hist.scott()</code> 可以自动指派 bin 宽度。<br>
<code>MASS::truehist()</code><br>
<code>ggplot2::geom_histogram()</code><br>
<code>ggplot2::geom_freqpoly()</code><br>
<code>plotrix::histStack()</code><br>
<code>plotrix::multhist()</code><br>
<code>plotrix::plotH()</code><br>
<code>plotrix::weighted.hist()</code><br>
<code>psych::multi.hist()</code><br>
<code>psych::pairs.panels()</code><br>
<code>psych::scatter.hist()</code></p>
<p>等等</p>
<h1 id="其他统计图">其他统计图</h1>
<p>Mosaic Plot 类别数据，面积大小相对比例<br>
Heat Map 多变量关系，通过色彩深浅区分频率、密度和大小<br>
Pareto chart 条形图+累加线图，质量控制<br>
Sparkline 时间序列，气候，金融<br>
Radar chart 雷达图<br>
Line Chart 连续数据，趋势，时间序列数据<br>
Bar Chart 类别数据，大小比较<br>
Correlogram 相关图，展示相关矩阵</p>
<p>参考：<a href="https://en.wikipedia.org/wiki/List_of_graphical_methods" target="_blank" rel="external">Wikipedia: List of graphical methods</a></p>
<h1 id="数据可视化的几点原则">数据可视化的几点原则</h1>
<blockquote>
<p>Graphical displays should:</p>
<ul>
<li>show the data 显示原始数据</li>
<li>induce the viewer to think about the substance rather than about methodology, graphic design, the technology of graphic production or something else 引导观察者思考内容而非其他</li>
<li>avoid distorting what the data has to say 避免扭曲真实数据要展现的东西</li>
<li>present many numbers in a small space 在较小的空间展现大量的数据</li>
<li>make large data sets coherent 让大数据集具有一致性（清晰明了）？</li>
<li>encourage the eye to compare different pieces of data 鼓励用眼睛去比较数据之间的差异</li>
<li>reveal the data at several levels of detail, from a broad overview to the fine structure 从宏观到微观揭示数据表达的信息</li>
<li>serve a reasonably clear purpose: description, exploration, tabulation or decoration 服务于合理清晰的目标：描述，探索，制表或者装饰？</li>
<li>be closely integrated with the statistical and verbal descriptions of a data set. 紧密整合统计和言语上对数据集的描述</li>
</ul>
<p>— The Visual Display of Quantitative Information, Edward Tufte</p>
</blockquote>
<h1 id="统计图表所要展示的一些定量信息">统计图表所要展示的一些定量信息</h1>
<p>参考：<a href="https://en.wikipedia.org/wiki/Data_visualization" target="_blank" rel="external">Wikipedia: Data Visualization</a></p>
<blockquote>
<p>Quantitative messages</p>
<p>Author Stephen Few described eight types of quantitative messages that users may attempt to understand or communicate from a set of data and the associated graphs used to help communicate the message:</p>
<ul>
<li><strong>Time-series</strong>: A single variable is captured over a period of time. A line chart may be used to demonstrate the trend. 时序，随着时间发展而变化</li>
<li><strong>Ranking</strong>: Categorical subdivisions are ranked in ascending or descending order. A bar chart may be used to show the comparison across the sales persons. 顺序，类别之间的大小顺序</li>
<li><strong>Part-to-whole</strong>: Categorical subdivisions are measured as a ratio to the whole. A bar chart can show the comparison of ratios. 部分相对于整体的比例</li>
<li><strong>Deviation</strong>: Categorical subdivisions are compared against a reference. A bar chart can show comparison of the actual versus the reference amount. 变异，与参考对象进行比较</li>
<li><strong>Frequency distribution</strong>: Shows the number of observations of a particular variable for given interval. A histogram, a type of bar chart, may be used for this analysis. A boxplot helps visualize key statistics about the distribution, such as median, quartiles, outliers, etc. 频率分布</li>
<li><strong>Correlation</strong>: Comparison between observations represented by two variables (X,Y) to determine if they tend to move in the same or opposite directions. A scatter plot is typically used for this message. 相关性</li>
<li><strong>Nominal comparison</strong>: Comparing categorical subdivisions in no particular order. A bar chart may be used for this comparison. 类别比较，无特定顺序</li>
<li><strong>Geographic or geospatial</strong>: Comparison of a variable across a map or layout. A cartogram is a typical graphic used. 地理和空间信息</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近需要分析毕业论文数据，借机温习一下常见的统计图形，并且熟悉下如何在 R 下进行数据可视化。&lt;/p&gt;
&lt;h1 id=&quot;箱图-boxplot&quot;&gt;箱图 Boxplot&lt;/h1&gt;
&lt;h2 id=&quot;什么是箱图？&quot;&gt;什么是箱图？&lt;/h2&gt;
&lt;p&gt;箱形图，又叫箱须图（Box-Whis
    
    </summary>
    
      <category term="Notes" scheme="blog.alexiangli.com/categories/Notes/"/>
    
    
      <category term="R" scheme="blog.alexiangli.com/tags/R/"/>
    
      <category term="Data viz" scheme="blog.alexiangli.com/tags/Data-viz/"/>
    
  </entry>
  
  <entry>
    <title>R：描述性统计</title>
    <link href="blog.alexiangli.com/r-descriptive-stats/"/>
    <id>blog.alexiangli.com/r-descriptive-stats/</id>
    <published>2016-11-07T16:00:00.000Z</published>
    <updated>2016-11-19T03:31:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>获取数据表的属性：</p>
<ul>
<li><code>str(data)</code> 数据构成</li>
<li>列数：<code>ncol(data)</code></li>
<li>行数：<code>nrow(data)</code></li>
<li>名称：<code>names(data)</code> 或者 <code>col.names(data)</code> <code>row.names(data)</code></li>
<li>长度：<code>length(data)</code> 或者查看某一列的唯一值个数 <code>length(unique(data[,&quot;col_name&quot;]))</code> 或者 <code>length(unique(data$col_name))</code></li>
</ul>
<p>描述性统计：</p>
<p>直接使用 <code>summary(data)</code> 就可以得到描述性统计值。<code>summary</code> 会根据输入对象的类型而返回不同的统计值。<br>
如果对象为 <code>charactor</code> 那么得到的是字符串总长度和 <code>Class</code> 和 <code>Mode</code>。如果对象为 <code>factor</code>，得到的是每个 <code>factor</code> 的数目。如果是 <code>integer</code>，得到的是最小值、中位数、平均数、四分位数、最大值。</p>
<p>如果用特定的计算统计量的函数呢？</p>
<ul>
<li>最小值 <code>min(data$col_name)</code></li>
<li>最大值 <code>max(data$col_name)</code></li>
<li>标准差 <code>sd(data$col_name)</code></li>
<li>方差 <code>var(data$col_name)</code></li>
<li>均值 <code>mean(data$col_name)</code></li>
<li>四分位数 <code>quantile(data$col_name, c(0.25, 0.75))</code></li>
<li>中位数 <code>median(data$col_name)</code></li>
<li>中位数绝对偏差 <code>mad(data$col_name)</code></li>
</ul>
<p>还有偏度和峰度两个描述性统计指标，但是 R 基本包里头没有提供直接算的函数。要么自己写一个函数，要么使用第三方开发包中的函数计算。</p>
<p>参考<a href="http://jackycode.github.io/blog/2014/03/12/rseries5/" target="_blank" rel="external">这篇博文</a>，作者给出了公式和代码：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">desc.stats &lt;- <span class="keyword">function</span>(x, na.omit=<span class="literal">FALSE</span> &#123;</div><div class="line">  <span class="keyword">if</span> (na.omit)</div><div class="line">    x &lt;- x[!is.na(x)]</div><div class="line">  n &lt;- length(x)</div><div class="line">  mean &lt;- mean(x)</div><div class="line">  var &lt;- var(x)</div><div class="line">  sd &lt;- sd(x)</div><div class="line">  skew &lt;- sum((x-mean)^<span class="number">3</span>/sd^<span class="number">3</span>)/n <span class="comment">#计算偏度</span></div><div class="line">  kurt &lt;- sum((x-mean)^<span class="number">4</span>/sd^<span class="number">4</span>)/n - <span class="number">3</span> <span class="comment">#计算峰度</span></div><div class="line">  <span class="keyword">return</span>(list(Mean=mean, Variance=var, skewness=skew, kurtosis=kurt))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有有哪些包提供了描述性统计的函数呢？</p>
<ul>
<li><code>Hmisc</code> 包中的 <code>Hmisc::describe()</code> 函数，可以返回变量数目、缺失值数目、均值、分位数等；</li>
<li><code>fBasic</code> 包中有 <code>skewness()</code> 和 <code>kurtosis()</code> 函数分别计算偏度和峰度；该包还有一个 <code>fBasic::basicStats()</code> 可以得到大部分描述性统计量。</li>
<li><code>psych</code> 专门用于心理统计学的包，里头也有关于描述性统计的函数，<code>psych::describe()</code> <code>psych::describeData()</code> <code>psych::describeBy()</code></li>
</ul>
<p>如果按照组或者变量水平来进行描述性统计呢？</p>
<ul>
<li>可以使用基本包里头的向量化运算的 <code>apply()</code> 族，<code>by()</code> <code>aggregate()</code> 等。</li>
<li>Hackley 大神开发的 <code>plyr</code> 和加强版 <code>dplyr</code> 也是可以组的描述性统计的。</li>
<li>还有如 <code>psych::describeBy()</code> <code>doBy::summaryBy()</code></li>
</ul>
<p>参考: <a href="http://www.statmethods.net/stats/descriptives.html" target="_blank" rel="external">Quick-R: Descriptive Statistics</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;获取数据表的属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;str(data)&lt;/code&gt; 数据构成&lt;/li&gt;
&lt;li&gt;列数：&lt;code&gt;ncol(data)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;行数：&lt;code&gt;nrow(data)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;名称：&lt;c
    
    </summary>
    
      <category term="Notes" scheme="blog.alexiangli.com/categories/Notes/"/>
    
    
      <category term="R" scheme="blog.alexiangli.com/tags/R/"/>
    
      <category term="R-basics" scheme="blog.alexiangli.com/tags/R-basics/"/>
    
      <category term="Statistics" scheme="blog.alexiangli.com/tags/Statistics/"/>
    
  </entry>
  
  <entry>
    <title>构建自动化</title>
    <link href="blog.alexiangli.com/front-end-automation/"/>
    <id>blog.alexiangli.com/front-end-automation/</id>
    <published>2016-10-29T06:03:30.000Z</published>
    <updated>2017-01-27T09:57:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天修改了下博客模板，顺便了解了下相关的工具和模块。</p>
<h1 id="hexo">HEXO</h1>
<p>辅助函数</p>
<p><code>url_for()</code> 在路径前加根目录 <code>&lt;% url_for(path) %&gt;</code><br>
<code>relative_url(from, to)</code> 获得一个从 <code>from</code> 到 <code>to</code> 的路径<br>
<code>css(path, ...)</code> 载入 css 文件<br>
<code>js(path, ...)</code> 载入 js 文件<br>
<code>link_to(path, [text], [options])</code> 插入链接<br>
<code>mail_to(path, [text], [options])</code> 插入电子邮件<br>
<code>image_tag(path, [options])</code> 插入图片<br>
<code>favicon_tag(path)</code> 插入 favicon<br>
<code>feed_tag(path, [options])</code> 插入 feed 链接<br>
<code>is_*()</code> 系列条件函数，<code>current</code> <code>home</code> <code>post</code> <code>archive</code> <code>year</code> <code>month</code> <code>category</code> <code>tag</code></p>
<p><code>partial(layout, [locals], [options])</code> 载入其他模板文件，您可在 locals 设定区域变量。<br>
<code>paginator(options)</code> 插入分页链接<br>
<code>toc(str, [options])</code></p>
<p><code>__('next')</code> 多语言支持时，<code>__()</code> 用于转换语言。</p>
<blockquote>
<p>在模板中，透过 __ 或 _p 辅助函数，即可取得翻译后的字符串，前者用于一般使用；而后者用于复数字符串。</p>
</blockquote>
<h1 id="grunt"><a href="http://www.gruntjs.net/" target="_blank" rel="external">Grunt</a></h1>
<h2 id="构建自动化">构建自动化</h2>
<p>谈 Grunt，就要谈到“构建自动化”。</p>
<blockquote>
<p><strong>Build automation</strong> is the process of automating the creation of a software build and the associated processes including: compiling computer source code into binary code, packaging binary code, and running automated tests.</p>
</blockquote>
<p>构建自动化有以下一些好处：</p>
<blockquote>
<ul>
<li>A necessary pre-condition for continuous integration and continuous testing 在连续集成和测试中的必要的前置条件</li>
<li>Improve product quality 改善产品质量</li>
<li>Accelerate the compile and link processing 加速编译和链接处理</li>
<li>Eliminate redundant tasks 去除冗余的任务</li>
<li>Minimize “bad builds” 减少低质量的构建</li>
<li>Eliminate dependencies on key personnel 去除关键的人员依赖</li>
<li>Have history of builds and releases in order to investigate issues 具有可供查询的构建和发布历史</li>
<li>Save time and money - because of the reasons listed above 节省时间和财力</li>
</ul>
</blockquote>
<h2 id="使用-grunt">使用 Grunt</h2>
<p>使用 Grunt 可以加快开发和自动构建。可以帮助开发者将压缩、编译、单元测试、代码检查等工作自动化。</p>
<p>三步使用 grunt：</p>
<blockquote>
<ul>
<li>Change to the project’s root directory.</li>
<li>Install project dependencies with npm install.</li>
<li>Run Grunt with grunt.</li>
</ul>
</blockquote>
<p><code>package.json</code> 保存项目元数据；<br>
<code>Gruntfile.js</code> 配置或定义任务、加载 Grunt 插件。<br>
<code>npm install &lt;module&gt; --save-dev</code> 本地安装并将依赖写入 <code>package.json</code> 中 <code>devDependencies</code>。</p>
<h2 id="gruntfile-js-配置文件"><code>Gruntfile.js</code> 配置文件</h2>
<p>Gruntfile.js 包括下面四个部分：</p>
<blockquote>
<ul>
<li>The “wrapper” function</li>
<li>Project and task configuration</li>
<li>Loading Grunt plugins and tasks</li>
<li>Custom tasks</li>
</ul>
</blockquote>
<p>包装函数（wrapper function）：概括 grunt 的配置信息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">grunt</span>) </span>&#123;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在包装函数内，初始化配置对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">grunt.initConfig(&#123;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>将 <code>package.json</code> 的项目设置保存到 <code>pkg</code> 属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pkg: grunt.file.readJSON(<span class="string">'package.json'</span>)</div></pre></td></tr></table></figure>
<p>插件配置（grunt-contrib-concat 为例）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">concat: &#123;</div><div class="line">    options: &#123;</div><div class="line">        seperator: <span class="string">';'</span></div><div class="line">    &#125;,</div><div class="line">    dist: &#123;</div><div class="line">    src: [],</div><div class="line">    dest: <span class="string">''</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>加载用到的插件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grunt.loadNpmTasks(<span class="string">'grunt-contrib-concat'</span>);</div></pre></td></tr></table></figure>
<p>创建任务：</p>
<p>直接输入 <code>grunt</code> 执行默认任务（default）；<br>
输入 <code>grunt test</code> 可以执行自定义的任务。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">grunt.registerTask(<span class="string">'default'</span>, [<span class="string">'concat'</span>]);</div><div class="line">grunt.registerTask(<span class="string">'test'</span>, [<span class="string">'jshint'</span>]);</div></pre></td></tr></table></figure>
<p>Grunt 常见插件：</p>
<p><code>grunt-contrib-uglify</code> 压缩 js, css 文件<br>
<code>grunt-contrib-concat</code> 连接文件<br>
<code>grunt-contrib-jshint</code> js 代码检测<br>
<code>grunt-contrib-watch</code> 代码监视</p>
<h1 id="gulp"><a href="http://www.gulpjs.com.cn/" target="_blank" rel="external">Gulp</a></h1>
<p>Gulp 和 Grunt 干差不多的活，目前还不知道优劣。Gulp 显得简单一些。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</div><div class="line"></div><div class="line">gulp.task(<span class="string">'default'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 将你的默认的任务代码放在这</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h1 id="ejs">EJS</h1>
<blockquote>
<p>EJS 是一个简单的模板语言，可以让你使用原生 JavaScript 生成 HTML 标记。没有关于如何组织内容的语法规则，也没有循环和控制流的重载，只是使用原生的 JavaScript。</p>
</blockquote>
<p>EJS 一个在 HTML 中嵌入原生 JS 语言的模板语言。</p>
<p>有以下特点：</p>
<blockquote>
<p>快速的编写和解析<br>
简单的模板标签: &lt;% %&gt;<br>
自定义分隔符（例如使用 <? ?>替换&lt;% %&gt;）<br>
使用 include 引入其他模板<br>
同时支持服务器端和客户端使用<br>
JavaScript 的静态缓存<br>
模板的静态缓存<br>
与 Express 视图系统兼容</p>
</blockquote>
<p>一个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ejs = <span class="built_in">require</span>(<span class="string">'ejs'</span>), <span class="comment">// 加载 ejs 模块</span></div><div class="line">    people = [<span class="string">'geddy'</span>, <span class="string">'neil'</span>, <span class="string">'alex'</span>], <span class="comment">// 数据</span></div><div class="line">    html = ejs.render(<span class="string">'&lt;%= people.join(", "); %&gt;'</span>, &#123;people: people&#125;); <span class="comment">// ejs 渲染</span></div></pre></td></tr></table></figure>
<p>熟悉这几个标签：</p>
<ul>
<li><code>&lt;%</code> ‘Scriptlet’ 标签, 用于控制流，没有输出</li>
<li><code>&lt;%=</code> 向模板输出值（带有转义）</li>
<li><code>&lt;%-</code> 向模板输出没有转义的值</li>
<li><code>&lt;%#</code> 注释标签，不执行，也没有输出</li>
<li><code>&lt;%%</code> 输出字面的 ‘&lt;%’</li>
<li><code>%&gt;</code> 普通的结束标签</li>
<li><code>-%&gt;</code> Trim-mode (‘newline slurp’) 标签, 移除随后的换行符</li>
</ul>
<p>使用 <code>include</code> 调用的模板时路径需要 filename 选项。</p>
<h1 id="jade">JADE</h1>
<p>JADE（现在改名为 Pugjs） 是一个极度注重代码简洁性的模板语言。相比 EJS 来说，渲染性能较低一些。但因为其简单的语法（对其他人来说也许算是“复杂”了）受到欢迎。</p>
<p>下面记录一些容易忘记的特殊语法：</p>
<p><code>= '\n'</code> 换行<br>
<code>!=</code> 不转义的属性</p>
<blockquote>
<p>未经转义的缓存代码十分危险。您必须正确处理和过滤用户的输入来避免跨站脚本攻击。</p>
</blockquote>
<p><code>'${}'</code> 字符串中嵌入变量</p>
<p><code>&amp;attributes({'data-foo': 'bar'})</code> 语法可以将一个对象转化为一个元素的属性列表</p>
<p>分支条件（Case）：case 是 JavaScript 的 switch 指令的缩写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- var foo = 10</div><div class="line">case foo</div><div class="line">    when 0</div><div class="line">        p eee</div><div class="line">    when 1</div><div class="line">        p fff</div><div class="line">    default</div><div class="line">        p ggg #&#123;foo&#125;</div></pre></td></tr></table></figure>
<p>分支传递 (Case Fall Through) :在 Pug 中，传递会在遇到非空的语法块前一直进行下去。如果不想输出任何东西的话，可以明确地加上一个原生的 break 语句。也可以使用块展开的语法</p>
<p>由 <code>-</code> 开始的一段为不输出的代码。另起一行并缩进可以写成块的形式。<br>
用 <code>=</code> 开始一段带有输出的代码，它应该是可以被求值的一个 JavaScript 表达式。<br>
用 <code>!=</code> 开始一段不转义的，带有输出的代码。</p>
<p>用 <code>//-</code> 进行单行注释，使用 <code>//</code> 并另起一行缩进，可进行块注释。pug 的条件注释跟 html 一样，并没有特殊的写法。</p>
<p>条件判断形式可以省略开头的 <code>-</code>, <code>if !x</code> === <code>unless x</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if x</div><div class="line">else if y</div><div class="line">else</div><div class="line">    z</div></pre></td></tr></table></figure>
<p>模板继承：<code>extends</code> 关键字允许模板去扩展一个布局或父模板，这样它就可以覆盖某些预定义的内容。</p>
<p>包含 <code>include</code> 功能允许您把另外的文件内容插入进来。</p>
<p>Pug 支持使用 <code>block</code> 和 <code>extends</code> 关键字进行模板的继承。一个称之为“块”（block）的代码块，可以被子模板覆盖、替换。这个过程是递归的。</p>
<p>Pug 允许您去替换（默认的行为）、<code>prepend</code>（向头部添加内容），或者 <code>append</code>（向尾部添加内容）一个块。当使用 <code>block append</code> 或者 <code>block prepend</code> 时，<code>block</code> 关键字是可省略的</p>
<p>嵌入 Interpolation：Pug 提供了好几种方式满足不同的嵌入需求。</p>
<p>迭代 Iteration</p>
<p><code>each</code> <code>each ... in ...</code> <code>each val, index in arr</code></p>
<p><code>for</code> <code>while</code> 也可以创建迭代</p>
<p>混入 Mixin：混入是一种允许您在 Pug 中重复使用一整个代码块的方法。<code>mixin</code> 可以写成函数形式，传入参数。在使用 <code>mixin</code> 的函数形式时，在前面加上 <code>+</code> 号，即 <code>+foo(faz)</code>。还可以使用剩余参数（rest arguments）<code>...</code> 语法来表示参数列表传入若干长度不定的参数。</p>
<p>放置纯文本</p>
<ul>
<li>管道文本：在每行加一个 <code>|</code> 字符。</li>
<li>标签的行内：文本只需要和标签名隔开一个空格。</li>
<li>标签中的块：在标签后街上一个 <code>.</code> 点号（没有空格）。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天修改了下博客模板，顺便了解了下相关的工具和模块。&lt;/p&gt;
&lt;h1 id=&quot;hexo&quot;&gt;HEXO&lt;/h1&gt;
&lt;p&gt;辅助函数&lt;/p&gt;
&lt;p&gt;&lt;code&gt;url_for()&lt;/code&gt; 在路径前加根目录 &lt;code&gt;&amp;lt;% url_for(path) %&amp;gt;&lt;/co
    
    </summary>
    
      <category term="Daily" scheme="blog.alexiangli.com/categories/Daily/"/>
    
    
      <category term="Hexo" scheme="blog.alexiangli.com/tags/Hexo/"/>
    
      <category term="Grunt" scheme="blog.alexiangli.com/tags/Grunt/"/>
    
      <category term="Gulp" scheme="blog.alexiangli.com/tags/Gulp/"/>
    
      <category term="Jade" scheme="blog.alexiangli.com/tags/Jade/"/>
    
      <category term="Pug.js" scheme="blog.alexiangli.com/tags/Pug-js/"/>
    
  </entry>
  
  <entry>
    <title>前端代码规范</title>
    <link href="blog.alexiangli.com/front-end-coding-style/"/>
    <id>blog.alexiangli.com/front-end-coding-style/</id>
    <published>2016-10-28T06:10:36.000Z</published>
    <updated>2017-01-27T09:55:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端代码规范">前端代码规范</h1>
<p><a href="http://codeguide.bootcss.com/" target="_blank" rel="external">代码规范 by @mdo</a></p>
<blockquote>
<p>不管有多少人共同参与同一项目，一定要确保每一行代码都像是同一个人编写的。</p>
</blockquote>
<h2 id="html">HTML</h2>
<ul>
<li>强烈建议为 html 根元素指定 lang 属性，从而为文档设置正确的语言；</li>
<li>在引入 CSS 和 JavaScript 文件时一般不需要指定 type 属性；</li>
<li>尽量最少使用标签，并保持最小的复杂度；</li>
<li>HTML 属性顺序：<code>class</code> (<code>id</code> <code>name</code>) <code>data-*</code> (<code>src</code> <code>for</code> <code>type</code> <code>href</code>) (<code>title</code> <code>alt</code>) (<code>aria-*</code>, <code>role</code>)；</li>
<li>布尔型属性不用赋值；</li>
<li>尽量避免多余的父元素；</li>
<li>尽量避免 JS 生成的标签。</li>
</ul>
<h2 id="css">CSS</h2>
<ul>
<li>用两个空格来代替制表符；</li>
<li>为选择器分组时，将单独的选择器单独放在一行；</li>
<li>在每个声明块的左花括号前添加一个空格；</li>
<li>声明块的右花括号应当单独成行；</li>
<li>每条声明语句的 <code>:</code> 后应该插入一个空格；</li>
<li>为了获得更准确的错误报告，每条声明都应该独占一行；</li>
<li>所有声明语句都应当以分号结尾；</li>
<li>对于以逗号分隔的属性值，每个逗号后面都应该插入一个空格；</li>
<li>不要在 <code>rgb()</code>、<code>rgba()</code>、<code>hsl()</code>、<code>hsla()</code> 或 <code>rect()</code> 值的内部的逗号后面插入空格；</li>
<li>对于属性值或颜色参数，省略小于 1 的小数前面的 0；</li>
<li>十六进制值应该全部小写；</li>
<li>尽量使用简写形式的十六进制值；</li>
<li>为选择器中的属性添加双引号；</li>
<li>避免为 0 值指定单位。</li>
</ul>
<h3 id="声明顺序">声明顺序</h3>
<p>相关的属性声明应当归为一组，并按照下面的顺序排列：</p>
<ul>
<li>Positioning</li>
<li>Box model</li>
<li>Typographic</li>
<li>Visual</li>
</ul>
<blockquote>
<p>由于定位（positioning）可以从正常的文档流中移除元素，并且还能覆盖盒模型（box model）相关的样式，因此排在首位。盒模型排在第二位，因为它决定了组件的尺寸和位置。其他属性只是影响组件的内部（inside）或者是不影响前两组属性，因此排在后面。</p>
</blockquote>
<h3 id="不要使用-import">不要使用 @import</h3>
<blockquote>
<p>与 <code>&lt;link&gt;</code> 标签相比，<code>@import</code> 指令要慢很多，不光增加了额外的请求次数，还会导致不可预料的问题。替代办法有以下几种：</p>
</blockquote>
<blockquote>
<ul>
<li>使用多个 <code>&lt;link&gt;</code> 元素</li>
<li>通过 Sass 或 Less 类似的 CSS 预处理器将多个 CSS 文件编译为一个文件</li>
<li>通过 Rails、Jekyll 或其他系统中提供过 CSS 文件合并功能</li>
</ul>
</blockquote>
<h3 id="媒体查询的位置">媒体查询的位置</h3>
<blockquote>
<p>将媒体查询放在尽可能相关规则的附近。不要将他们打包放在一个单一样式文件中或者放在文档底部。如果你把他们分开了，将来只会被大家遗忘。</p>
</blockquote>
<h3 id="单行规则声明">单行规则声明</h3>
<blockquote>
<p>对于只包含一条声明的样式，为了易读性和便于快速编辑，建议将语句放在同一行。对于带有多条声明的样式，还是应当将声明分为多行。</p>
</blockquote>
<h3 id="简写形式的属性声明">简写形式的属性声明</h3>
<blockquote>
<p>在需要显示地设置所有值的情况下，应当尽量限制使用简写形式的属性声明。过度使用简写形式的属性声明会导致代码混乱，并且会对属性值带来不必要的覆盖从而引起意外的副作用。</p>
</blockquote>
<h3 id="less-和-sass-中的嵌套">Less 和 Sass 中的嵌套</h3>
<p>避免非必要的嵌套。</p>
<h3 id="注释">注释</h3>
<blockquote>
<p>请确保你的代码能够自描述、注释良好并且易于他人理解。好的代码注释能够传达上下文关系和代码目的。不要简单地重申组件或 class 名称。对于较长的注释，务必书写完整的句子；对于一般性注解，可以书写简洁的短语。</p>
</blockquote>
<h3 id="class-命名">class 命名</h3>
<ul>
<li>class 名称中只能出现小写字符和破折号（dashe）；</li>
<li>破折号应当用于相关 class 的命名（类似于命名空间）；</li>
<li>避免过度任意的简写；</li>
<li>class 名称应当尽可能短，并且意义明确；</li>
<li>使用有意义的名称；</li>
<li>基于最近的父 class 或基本（base） class 作为新 class 的前缀。</li>
<li>使用 .js-* class 来标识行为（与样式相对），并且不要将这些 class 包含到 CSS 文件中。</li>
</ul>
<h3 id="选择器">选择器</h3>
<ul>
<li>对于通用元素使用 class ，这样利于渲染性能的优化。</li>
<li>对于经常出现的组件，避免使用属性选择器（例如，[class^=&quot;…&quot;]）。浏览器的性能会受到这些因素的影响。</li>
<li>选择器要尽可能短，并且尽量限制组成选择器的元素个数，建议不要超过 3；</li>
<li>只有在必要的时候才将 class 限制在最近的父元素内（也就是后代选择器）。</li>
</ul>
<p><code>合理使用标签</code> <code>降低选择器复杂度</code></p>
<h3 id="代码组织">代码组织</h3>
<ul>
<li>以组件为单位组织代码段。</li>
<li>制定一致的<strong>注释规范</strong>。</li>
<li><strong>使用一致的空白符将代码分隔成块</strong>，这样利于扫描较大的文档。</li>
<li>如果使用了多个 CSS 文件，将其<strong>按照组件而非页面的形式分拆</strong>，因为页面会被重组，而组件只会被移动。</li>
</ul>
<p><code>组件化</code> <code>块状</code></p>
<h3 id="编辑器配置">编辑器配置</h3>
<p>将你的编辑器按照下面的配置进行设置，以避免常见的代码不一致和差异：</p>
<ul>
<li>用两个空格代替制表符（soft-tab 即用空格代表 tab 符）。</li>
<li>保存文件时，删除尾部的空白符。</li>
<li>设置文件编码为 UTF-8。</li>
<li>在文件结尾添加一个空白行。</li>
</ul>
<p>在 Emacs 中配置两个空格缩进：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">(defun my/web-mode-indent-style ()</div><div class="line">    &quot;Personal web mode indent style.&quot;</div><div class="line">    ;; 设置默认的缩进方式</div><div class="line">    (setq-default indent-tabs-mode nil)</div><div class="line"></div><div class="line">    ;; 设置 web-mode 的缩进</div><div class="line">    (setq web-mode-markup-indent-offset 2</div><div class="line">        web-mode-css-indent-offset 2</div><div class="line">        web-mode-code-indent-offset 2</div><div class="line">        web-mode-indent-style 2)</div><div class="line">)</div><div class="line">(add-hook &apos;web-mode-book &apos;my/web-mode-indent-style)</div><div class="line"></div><div class="line">;; 设置 CSS 缩进</div><div class="line">(setq css-indent-offset 2)</div></pre></td></tr></table></figure>
<hr>
<h1 id="emacs">Emacs</h1>
<h2 id="golden-ratio-mode">golden-ratio-mode</h2>
<p>当开启多个缓冲区（buffers）时，希望对不同的 buffer 高度和宽度进行调整。<a href="https://github.com/roman/golden-ratio.el" target="_blank" rel="external">golden-ratio-mode</a> 满足此要求，可用于自动调整 buffer 宽高。当切换到某个 buffer，会自动增加活动 buffer 的高度或宽度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(use-package golden-ratio</div><div class="line">  :ensure t</div><div class="line">  :diminish golden-ratio-mode</div><div class="line">  :init</div><div class="line">  (progn</div><div class="line">  (golden-ratio-mode t) ;; 开启 golden-ratio</div><div class="line">  (setq golden-ratio-adjust-factor .8 ;; 调整垂直比例</div><div class="line">    golden-ratio-wide-adjust-factor .8 ;; 调整水平宽度比例</div><div class="line">    golden-ratio-exclude-modes &apos;(list &quot;projectile-mode&quot; &quot;project-explorer-mode&quot;) ;; 指定不使用 golden-ratio 的 major-mode</div><div class="line">    )</div><div class="line">    (golden-ratio-toggle-widescreen) ;; 开启宽屏模式</div><div class="line">    ))</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前端代码规范&quot;&gt;前端代码规范&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;http://codeguide.bootcss.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;代码规范 by @mdo&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不
    
    </summary>
    
      <category term="Daily" scheme="blog.alexiangli.com/categories/Daily/"/>
    
    
      <category term="JavaScript" scheme="blog.alexiangli.com/tags/JavaScript/"/>
    
      <category term="Coding style" scheme="blog.alexiangli.com/tags/Coding-style/"/>
    
      <category term="HTML" scheme="blog.alexiangli.com/tags/HTML/"/>
    
      <category term="CSS" scheme="blog.alexiangli.com/tags/CSS/"/>
    
      <category term="Emacs" scheme="blog.alexiangli.com/tags/Emacs/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 学习记录</title>
    <link href="blog.alexiangli.com/learn-http/"/>
    <id>blog.alexiangli.com/learn-http/</id>
    <published>2016-10-22T11:45:33.000Z</published>
    <updated>2016-11-28T12:44:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP/0.9 —&gt; HTTP/1.0 —&gt; HTTP/1.1 —&gt; SPDY 协议 —&gt; HTTP/2</p>
<h1 id="http-1-0">HTTP/1.0</h1>
<p>主要缺点：每个 TCP 连接只能发送一个请求。TCP 连接的新建成本高，所以 HTTP/1.0 性能较差。为了避免这个问题，在浏览器请求时，使用一个非标准的 <code>Connection</code> 字段：<code>Connection: keep-alive</code>，要求服务器不要关闭 TCP 连接，以便其他请求复用。然而，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。</p>
<h1 id="http-1-1">HTTP/1.1</h1>
<p>目前是最流行的版本。该版本最大的变化是，引入了<strong>持久连接（persistent connection）</strong>，即 TCP 连接默认不关闭，可被多个请求复用，无须申明 <code>Connection: keep-alive</code>。当客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。更规范的做法是，在客户端最后一次请求时，发送 <code>Connection: close</code>，明确要求服务器关闭 TCP 连接。</p>
<p>引入管道机制：在同一个 TCP 连接里面，客户端可以同时发送多个请求。</p>
<p>缺点：虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这就会出现&quot;队头堵塞&quot;（Head-of-line blocking）。</p>
<h1 id="http-2">HTTP/2</h1>
<ul>
<li>二进制协议：头信息和数据体都是二进制，并且统称为&quot;帧&quot;（frame）：头信息帧和数据帧。<br>
多工：双向的、实时的通信。</li>
<li>数据流：HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流 ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID 一律为奇数，服务器发出的，ID 为偶数。</li>
<li>头信息压缩机制（header compression）</li>
<li>服务器推送</li>
</ul>
<p>问题：</p>
<ol>
<li>HTTP/1.0 相对于 HTTP/0.9 有哪些新标准？HTTP/1.0 有什么缺点？</li>
<li>HTTP/1.1 相对于 HTTP/1.0 有哪些新标准？HTTP/1.1 有什么缺点？</li>
<li>HTTP/2 相对于 HTTP/1.1 有哪些新标准？</li>
<li>HTTPS 是什么？与 HTTP/2 有什么差别？</li>
</ol>
<p>参考资料：</p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="external">阮一峰：HTTP 协议入门</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP/0.9 —&amp;gt; HTTP/1.0 —&amp;gt; HTTP/1.1 —&amp;gt; SPDY 协议 —&amp;gt; HTTP/2&lt;/p&gt;
&lt;h1 id=&quot;http-1-0&quot;&gt;HTTP/1.0&lt;/h1&gt;
&lt;p&gt;主要缺点：每个 TCP 连接只能发送一个请求。TCP 连接的新建
    
    </summary>
    
      <category term="Notes" scheme="blog.alexiangli.com/categories/Notes/"/>
    
      <category term="Web" scheme="blog.alexiangli.com/categories/Notes/Web/"/>
    
    
      <category term="HTTP" scheme="blog.alexiangli.com/tags/HTTP/"/>
    
      <category term="Web" scheme="blog.alexiangli.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>D3.js 入门学习记录</title>
    <link href="blog.alexiangli.com/d3-intro/"/>
    <id>blog.alexiangli.com/d3-intro/</id>
    <published>2016-10-17T08:23:07.000Z</published>
    <updated>2017-01-27T08:27:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://Dashingd3js.com" target="_blank" rel="external">Dashingd3js.com</a> 上的 D3.js 教程学习笔记。</p>
<h1 id="添加-dom-元素">添加 DOM 元素</h1>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">d3.select(<span class="string">"body"</span>).append(<span class="string">"p"</span>);</div></pre></td></tr></table></figure>
<p><code>D3.select()</code> 选择方法使用 CSS3 选择器来抓取 DOM 元素。当元素被选中，算子（operators）能够获取或设置属性、样式、文本内容等。</p>
<p><code>D3.append()</code> 添加元素为当前选中的父级元素的最后一个子元素。</p>
<h1 id="添加-svg-元素">添加 SVG 元素</h1>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">d3.select(<span class="string">"body"</span>)</div><div class="line">  .append(<span class="string">"svg"</span>)</div><div class="line">  .attr(<span class="string">"width"</span>, <span class="number">50</span>)</div><div class="line">  .attr(<span class="string">"height"</span>, <span class="number">50</span>)</div><div class="line">  .append(<span class="string">"circle"</span>)</div><div class="line">  .attr(<span class="string">"cx"</span>, <span class="number">25</span>)</div><div class="line">  .attr(<span class="string">"cy"</span>, <span class="number">25</span>)</div><div class="line">  .attr(<span class="string">"r"</span>, <span class="number">25</span>)</div><div class="line">  .style(<span class="string">"fill"</span>, <span class="string">"purple"</span>)</div></pre></td></tr></table></figure>
<p><code>d3.style()</code> 样式算子对元素的样式进行操作。</p>
<p>与 jQuery 类似，D3js 通过点号 <code>.</code> 构成链式语法。在链式语法中，结果与算子和方法顺序有关。</p>
<h1 id="捆绑数据到-dom-元素中">捆绑数据到 DOM 元素中</h1>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> theData = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ]</div><div class="line"><span class="keyword">var</span> p = d3.select(<span class="string">"body"</span>).selectAll(<span class="string">"p"</span>)</div><div class="line">    .data(theData)</div><div class="line">    .enter()</div><div class="line">    .append(<span class="string">"p"</span>)</div><div class="line">    .text(<span class="string">"Hello "</span>);</div></pre></td></tr></table></figure>
<p><code>d3.selectAll()</code> 全选方法选择所有与选择器字符串匹配的 DOM 元素。但是上面的代码里头，并并有实际选择元素，而是返回的空选择（虚拟选择）。后面通过 <code>.data()</code> 和 <code>.enter()</code> 将数据绑定到空选择中。</p>
<p><code>.enter()</code> 方法从数据算子中返回虚拟键入选择，返回占位符元素。该方法只在 <code>.data()</code> 上操作生效。</p>
<p><code>.append()</code> 在占位符上添加 DOM 元素。</p>
<p><code>.text()</code> 文本方法添加文本到对于 DOM 元素上。</p>
<p>其中，数据被保存在 <code>__data__</code> 属性中。</p>
<p>如何将捆绑的数据提取出来呢？</p>
<p><code>.text( function(d) { return d; } )</code> 其中，匿名函数会对遍历所有元素的数据，分别返回对于的值。<code>d</code> 变量在 D3.js 被用来指代当前元素的 <code>__data__</code> 属性。另外，D3.js 还提供了两个变量 <code>this</code> 和 <code>i</code>。<code>this</code> 指代当前 DOM 元素。<code>i</code> 指代当前选中的元素的下标，<code>i</code> 从0开始计数。所有数据是按顺序分别处理。</p>
<h1 id="根据数据创建-svg-元素">根据数据创建 SVG 元素</h1>
<p>建立数组：<code>var newArray = [10, 20, 30];</code><br>
将数据指派给 SVG 元素的属性值 <code>.attr('r', function (d) { return d; }</code></p>
<h1 id="使用-svg-坐标空间">使用 SVG 坐标空间</h1>
<p>SVG 的坐标空间与数学中的坐标空间有两点差异：</p>
<ul>
<li>SVG 的坐标空间的零点位于左上角；</li>
<li>SVG 的坐标空间的 Y 轴由上至下延伸。</li>
</ul>
<h1 id="d3-js-支持的数据结构">D3.js 支持的数据结构</h1>
<p>数组（Array）：<code>var newArray = [30, 70, 110];</code> 数组可以包含任何对象，包括数字，对象，字符串，数组，HTML元素，DOM元素等。</p>
<p><code>d3.select()</code> 所得到的也是数组。</p>
<p>D3.js 可以支持以下数据来源：</p>
<ul>
<li>XMLHttpRequest</li>
<li>文本文件</li>
<li>JSON blob</li>
<li>HTML 文档块</li>
<li>XML 文档块</li>
<li>CSV 文件</li>
<li>TSV 文件</li>
</ul>
<p>数组甚至可以包含 JSON 数据结构。</p>
<h1 id="使用-json-对象">使用 JSON 对象</h1>
<p>使用 JSON 数据结构可以简化代码，使用起来更方便。</p>
<h1 id="使用-d3-js-绘制-svg-基本形状的图形">使用 D3.js 绘制 SVG 基本形状的图形</h1>
<p>只要知道相关图形元素的属性，那么就可以通过 D3.js 的算子进行操作了。</p>
<p>绘制一个圆</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"50"</span> <span class="attr">height</span>=<span class="string">"50"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">"25"</span> <span class="attr">cy</span>=<span class="string">"25"</span> <span class="attr">r</span>=<span class="string">"25"</span> <span class="attr">fill</span>=<span class="string">"purple"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> jsonCircle = [ &#123; <span class="string">"x_axis"</span>: <span class="number">30</span>, <span class="string">"y_axis"</span>: <span class="number">30</span>, <span class="string">"radius"</span>: <span class="number">20</span>, <span class="string">"color"</span>: <span class="string">"green"</span>&#125; ];</div><div class="line"><span class="keyword">var</span> svgContainer = d3.select(<span class="string">"body"</span>).append(<span class="string">"svg"</span>)</div><div class="line">    .attr(<span class="string">"width"</span>, <span class="number">200</span>)</div><div class="line">    .attr(<span class="string">"height"</span>, <span class="number">200</span>)</div><div class="line"><span class="keyword">var</span> circles = svgContainer.selectAll(<span class="string">"circle"</span>)</div><div class="line">    .data(jsonCircles)</div><div class="line">    .enter()</div><div class="line">    .append(<span class="string">"circle"</span>)</div><div class="line"><span class="keyword">var</span> circleAttributes = circles</div><div class="line">    .attr(<span class="string">"cx"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> d.x_axis &#125;)</div><div class="line">    .attr(<span class="string">"cy"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> d.y_axis &#125;)</div><div class="line">    .attr(<span class="string">"r"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> d.radius&#125;)</div><div class="line">    .style(<span class="string">"fill"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> d.color &#125;);</div></pre></td></tr></table></figure>
<p>其他简单图形都差不多，只是属性不一样。以此类推。</p>
<h1 id="svg-路径">SVG 路径</h1>
<p>SVG 路径为一个图形的轮廓。可以使用 SVG 的路径绘制任意形状。路径可以比作钢笔落笔绘制轮廓的过程。路径由属性 <code>d</code> 表示，其语法包括一下几个部分：</p>
<ul>
<li>moveto：设置一个新的点</li>
<li>lineto：绘制一条直线</li>
<li>curveto：绘制一条曲线（贝塞尔曲线）</li>
<li>arc：椭圆或者圆弧</li>
<li>closepath：通过绘制线条封闭当前的图形</li>
</ul>
<p>例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"100"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">" M 10 25</span></span></div><div class="line">              L 10 75</div><div class="line">              L 60 75</div><div class="line">              L 10 25"</div><div class="line">              <span class="attr">stroke</span>=<span class="string">"red"</span> <span class="attr">stroke-width</span>=<span class="string">"2"</span> <span class="attr">fill</span>=<span class="string">"none"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></div></pre></td></tr></table></figure>
<p>其中，路径中的字母是大小写有区分的，大写为绝对定位，小写为相对定位。<br>
要绘制更复杂的图形，使用 SVG 是相当难的。所以 D3.js 可以拯救这部分需求的用户。</p>
<p>使用 D3.js 提供的绘制 SVG 路径的方法要方便许多。</p>
<p>绘制直线：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//The data for our line</span></div><div class="line"><span class="keyword">var</span> lineData = [ &#123; <span class="string">"x"</span>: <span class="number">1</span>,   <span class="string">"y"</span>: <span class="number">5</span>&#125;,  &#123; <span class="string">"x"</span>: <span class="number">20</span>,  <span class="string">"y"</span>: <span class="number">20</span>&#125;,</div><div class="line">                 &#123; <span class="string">"x"</span>: <span class="number">40</span>,  <span class="string">"y"</span>: <span class="number">10</span>&#125;, &#123; <span class="string">"x"</span>: <span class="number">60</span>,  <span class="string">"y"</span>: <span class="number">40</span>&#125;,</div><div class="line">                 &#123; <span class="string">"x"</span>: <span class="number">80</span>,  <span class="string">"y"</span>: <span class="number">5</span>&#125;,  &#123; <span class="string">"x"</span>: <span class="number">100</span>, <span class="string">"y"</span>: <span class="number">60</span>&#125;];</div><div class="line"></div><div class="line"><span class="comment">//This is the accessor function we talked about above</span></div><div class="line"><span class="keyword">var</span> lineFunction = d3.svg.line()</div><div class="line">                         .x(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> d.x; &#125;)</div><div class="line">                         .y(<span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> d.y; &#125;)</div><div class="line">                         .interpolate(<span class="string">"linear"</span>);</div><div class="line"></div><div class="line"><span class="comment">//The SVG Container</span></div><div class="line"><span class="keyword">var</span> svgContainer = d3.select(<span class="string">"body"</span>).append(<span class="string">"svg"</span>)</div><div class="line">                                    .attr(<span class="string">"width"</span>, <span class="number">200</span>)</div><div class="line">                                    .attr(<span class="string">"height"</span>, <span class="number">200</span>);</div><div class="line"></div><div class="line"><span class="comment">//The line SVG Path we draw</span></div><div class="line"><span class="keyword">var</span> lineGraph = svgContainer.append(<span class="string">"path"</span>)</div><div class="line">                            .attr(<span class="string">"d"</span>, lineFunction(lineData))</div><div class="line">                            .attr(<span class="string">"stroke"</span>, <span class="string">"blue"</span>)</div><div class="line">                            .attr(<span class="string">"stroke-width"</span>, <span class="number">2</span>)</div><div class="line">                            .attr(<span class="string">"fill"</span>, <span class="string">"none"</span>);</div></pre></td></tr></table></figure>
<p><code>.attr(&quot;d&quot;, lineFunction(lineData))</code> 将数据传递给数据寄存器，然后把数据返回给 SVG 路径命令。</p>
<p>D3.js 提供了 11 中不同的内插线形：</p>
<ul>
<li>linear</li>
<li>step-before</li>
<li>step-after</li>
<li>basis</li>
<li>basis-open</li>
<li>basis-closed</li>
<li>bundle</li>
<li>cardinal</li>
<li>cardinal-open</li>
<li>cardinal-closed</li>
<li>monotone</li>
</ul>
<p>D3.js 提供了多种路径数据产生器（Path data generators），它既是对象又是函数。</p>
<ul>
<li>d3.svg.line</li>
<li>d3.svg.line.radial</li>
<li>d3.svg.area</li>
<li>d3.svg.area.radial</li>
<li>d3.svg.arc</li>
<li>d3.svg.symbol</li>
<li>d3.svg.chord</li>
<li>d3.svg.diagonal</li>
<li>d3.svg.diagonal.radial</li>
</ul>
<h1 id="svg-动态坐标空间">SVG 动态坐标空间</h1>
<p>如果使坐标根据数据进行调整？当 SVG 容器空间的大小比其中的图形元素坐标要小，那会出现容器空间上无法显式出图形的问题。这个时候需要动态的 SVG 坐标空间。这个时候需要做的是，让容器空间的宽高随着数据而进行伸缩。</p>
<h1 id="d3-js-标尺-scales">D3.js 标尺（scales）</h1>
<p>与其让 SVG 容器大小适应数据，不如让数据适应容器。因为有的时候，数据的大小尺寸远远大于浏览器显示尺度。这个时候需要对数据进行伸缩变换以便适应空间。</p>
<p>D3.js 提供了一些方法进行数据的变换。</p>
<p>例如 <code>d3.scale.linear()</code> 线性变换</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> linearScale = d3.scale.linear()</div><div class="line">                    .domain([<span class="number">0</span>, <span class="number">10000</span>])</div><div class="line">                    .range([<span class="number">0</span>, <span class="number">100</span>])</div></pre></td></tr></table></figure>
<p><code>.domain()</code> 里输入的范围为原始数据的范围。<br>
<code>.range()</code> 里输入的范围为变换后的范围。</p>
<p>提供了计算最大值和最小值的方法：<code>d3.max()</code> <code>d3.min()</code></p>
<p>D3.js 的标尺类型有以下几种：</p>
<ul>
<li>Identity 1:1 的变换，适用于像素值</li>
<li>Linear 线性的变换</li>
<li>Power 和 Logarithmic 指数和对数变换</li>
<li>Quantize 和 Quantile 针对离散数据</li>
<li>Ordinal 针对非量化的数据，如名称，类别</li>
</ul>
<h1 id="svg-组元素">SVG 组元素</h1>
<p>SVG 组元素是一个包裹其他子元素的的容器，通过 <code>&lt;g&gt;...&lt;/g&gt;</code> 定义。组元素内可以包含任意组元素。任何对组元素的变换，都将影响其所包含的子元素。</p>
<p>组元素的作用：</p>
<ul>
<li>创建分组，可以使一组元素共享相同的属性</li>
<li>变换，对一组元素进行同样的变换</li>
</ul>
<p>在 D3.js 中构建组元素并增加变换属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> svgContainer = d3.select(<span class="string">"body"</span>).append(<span class="string">"svg"</span>)</div><div class="line">                                    .attr(<span class="string">"width"</span>, <span class="number">200</span>)</div><div class="line">                                    .attr(<span class="string">"height"</span>, <span class="number">200</span>);</div><div class="line"><span class="keyword">var</span> circleGroup = svgContainer.append(<span class="string">"g"</span>)</div><div class="line">                              .attr(<span class="string">"transform"</span>, <span class="string">"translate(80, 0)"</span>);</div></pre></td></tr></table></figure>
<h1 id="svg-文本元素">SVG 文本元素</h1>
<p>添加 SVG 文本元素跟添加图形类型，只是该元素有一些特殊的属性。同样，使用 D3.js 添加文本和添加图形一样，操纵文本元素的属性和值就可以了。</p>
<h1 id="svg-坐标轴-axes">SVG 坐标轴（Axes）</h1>
<p>使用 D3.js 绘制坐标轴和坐标刻度。</p>
<p>创建坐标轴对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xAxis = d3.svg.axis();</div></pre></td></tr></table></figure>
<p>传递尺度信息给坐标轴对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> axisScale = d3.scale.linear()</div><div class="line">                        .domain([<span class="number">0</span>, <span class="number">100</span>])</div><div class="line">                        .range([<span class="number">0</span>, <span class="number">100</span>]);</div><div class="line"><span class="keyword">var</span> xAxis = d3.svg.axis()</div><div class="line">                  .scale(axisScale);</div></pre></td></tr></table></figure>
<p>创建坐标轴组元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xAxisGroup = svgContainer.append(<span class="string">"g"</span>)</div><div class="line">                             .call(xAxis);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://Dashingd3js.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Dashingd3js.com&lt;/a&gt; 上的 D3.js 教程学习笔记。&lt;/p&gt;
&lt;h1 id=&quot;添加-dom-元素&quot;&gt;添加 DOM 元素&lt;/h1
    
    </summary>
    
      <category term="Notes" scheme="blog.alexiangli.com/categories/Notes/"/>
    
    
      <category term="D3.js" scheme="blog.alexiangli.com/tags/D3-js/"/>
    
      <category term="Data viz" scheme="blog.alexiangli.com/tags/Data-viz/"/>
    
      <category term="SVG" scheme="blog.alexiangli.com/tags/SVG/"/>
    
  </entry>
  
  <entry>
    <title>R：查看源代码</title>
    <link href="blog.alexiangli.com/r-source-code/"/>
    <id>blog.alexiangli.com/r-source-code/</id>
    <published>2016-10-08T14:23:57.000Z</published>
    <updated>2016-11-19T03:29:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote></blockquote>
<p>Updated in 2016-11-11</p>
<p>为了深入了解 R 语言，谷歌检索了阅读源代码的方法，在此整理和记录以便往后查阅。要直接从 R 命令行获取源代码，需要了解一些 R 语言编程知识。R 语言中函数或者方法有许多种，例如：</p>
<ul>
<li>in-built 函数</li>
<li>S3 范型函数</li>
<li>S4 范型函数</li>
<li>non-visible functions 隐藏函数</li>
<li>unexported functions</li>
<li>compiled code</li>
<li>infix operators</li>
</ul>
<p>不同类型函数获取源代码的方式不同。要获取源代码，首先直接执行函数（不带括号），观察返回结果。一般来说，普通函数会直接返回源代码。</p>
<p>如果返回的结果包含 <code>UseMethod(&quot;function&quot;)</code>，则表示该函数为 S3 范型函数，它根据对象类型的不同调用不同的方法。然后使用 <code>methods()</code> 列出特定的范型函数和与类有关的函数 <code>methods(function)</code> <code>methods(class=&quot;classname&quot;)</code>。我们可以看到返回一些带 <code>*</code> 的函数，这类函数为 <code>Non-visible functions</code>，即隐藏的函数，表示这类函数没有从语言包的命名空间导出。但是我们仍然可以查看隐藏函数的源代码，可通过 <code>:::</code> 函数查看，即 <code>pkgname:::function</code>。另外，还可以使用 <code>getAnywhere()</code> 获取。<code>getAnywhere()</code> 并不需要知道函数来自于哪个语言包。对于没有 <code>*</code> 的方法，直接运行即可获得源代码。另外，S3 范型函数还可以通过 <code>getS3method(function, class)</code> 获取源代码。</p>
<p>如果返回的结果包含 <code>standardGeneric(&quot;function&quot;)</code>，意味着该函数为 S4 范型函数。对于这类函数，先通过 <code>showMethods(function)</code> 获得方法对应的 <code>signature</code>（不知道是神马东西）。例如：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; showMethods(chol2inv)</div><div class="line">Function: chol2inv (package base)</div><div class="line">x=<span class="string">"ANY"</span></div><div class="line">x=<span class="string">"CHMfactor"</span></div><div class="line">x=<span class="string">"denseMatrix"</span></div><div class="line">x=<span class="string">"diagonalMatrix"</span></div><div class="line">x=<span class="string">"dtrMatrix"</span></div><div class="line">x=<span class="string">"sparseMatrix"</span></div></pre></td></tr></table></figure>
<p>其中 <code>x=&quot;ANY&quot;</code> 就是 signature。那么，可以通过 <code>getMethod(&quot;function&quot;, &quot;signature&quot;)</code> 获取源代码。<br>
有一些方法具有更复杂的 <code>signature</code>，例如：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">require</span>(raster)</div><div class="line">showMethods(extract)</div><div class="line">Function: extract (package raster)</div><div class="line">x=<span class="string">"Raster"</span>, y=<span class="string">"data.frame"</span></div><div class="line">x=<span class="string">"Raster"</span>, y=<span class="string">"Extent"</span></div><div class="line">x=<span class="string">"Raster"</span>, y=<span class="string">"matrix"</span></div><div class="line">x=<span class="string">"Raster"</span>, y=<span class="string">"SpatialLines"</span></div><div class="line">x=<span class="string">"Raster"</span>, y=<span class="string">"SpatialPoints"</span></div><div class="line">x=<span class="string">"Raster"</span>, y=<span class="string">"SpatialPolygons"</span></div><div class="line">x=<span class="string">"Raster"</span>, y=<span class="string">"vector"</span></div></pre></td></tr></table></figure>
<p>那么，可以通过 <code>getMethod(&quot;function&quot;, signature = c(x = &quot;Raster&quot;, y = &quot;SpatialPolygons&quot;))</code> 获取源代码。</p>
<p>对于 <code>unexported functions</code>，可以使用和隐藏函数一样的方法获取源代码，即 <code>:::</code> 或 <code>getAnywhere()</code>。对于 <code>compiled code</code>，即返回内容中有 <code>&lt;bytecode:0x294e410&gt;</code> 的函数，仍然可以从 R 命令行查阅源代码。但是对于函数中调用的 <code>.C</code> <code>.Call</code> <code>.Fortran</code> <code>.External</code> <code>.Internal</code> <code>.Primitive</code>，无法从命令行获取源代码，需要直接查看编译前的源代码。函数 <code>pryr::show_c_source</code> 可以直接在 Github 中找到 <code>.Internal</code> 和 <code>.Primitive</code> 调用的内容。</p>
<p>对于无法直接从命令行获取源代码的函数，可以直接下载原始语言包。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">## from CRAN</span></div><div class="line">download.packages(pkgs = <span class="string">"Matrix"</span>,</div><div class="line">                  destdir = <span class="string">"."</span>,</div><div class="line">                  type = <span class="string">"source"</span>)</div><div class="line"><span class="comment">## uncompressing and untaring</span></div><div class="line">untar(download.packages(pkgs = <span class="string">"Matrix"</span>,</div><div class="line">                        destdir = <span class="string">"."</span>,</div><div class="line">                        type = <span class="string">"source"</span>)[,<span class="number">2</span>])</div></pre></td></tr></table></figure>
<p>基本包的源代码，可以通过查阅 R 语言源代码： <a href="http://svn.r-project.org/R/trunk/" target="_blank" rel="external">Subversion repository</a> 或者 <a href="https://github.com/wch/r-source/tree/trunk" target="_blank" rel="external">Winston Chang’s github mirror</a>。对于其他来源的包，直接从相应网站获取。</p>
<p>最后，可以通过 <code>edit(getAnywhere(&quot;function&quot;), file = &quot;source_function.r&quot;)</code> 或者 <code>capture.output(getAnywhere(&quot;function&quot;), file = &quot;source_function.r&quot;)</code> 获得源代码的文本内容。</p>
<p>另外，还可以通过代码调试方法获得源代码 <code>debugonce(function)</code>，使用 <code>debug(function)</code> 需要使用 <code>undebug()</code> 结束调试。</p>
<p>对于 infix operators，即 <code>%%</code> <code>%*%</code> <code>%in%</code>，可以通过 <code>getAnywhere</code> 或者 使用 backticks ‘`’ 包裹然后执行即可返回源代码。</p>
<hr>
<p>参考资料：</p>
<ul>
<li><a href="http://stackoverflow.com/questions/19226816/how-can-i-view-the-source-code-for-a-function" target="_blank" rel="external">How can I view the source code for a function?</a> 主要参考资料</li>
<li><a href="http://stackoverflow.com/questions/6583265/what-does-s3-methods-mean-in-r/6583639#6583639" target="_blank" rel="external">What does “S3 methods” mean in R?</a></li>
<li><a href="http://yusung.blogspot.jp/2007/08/get-invisible-functions-or-internal.html" target="_blank" rel="external">Get source codes for invisible functions or internal functions in R</a></li>
<li><a href="http://stackoverflow.com/questions/5937832/how-do-i-show-the-source-code-of-an-s4-function-in-a-package" target="_blank" rel="external">How do I show the source code of an S4 function in a package?</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;/blockquote&gt;
&lt;p&gt;Updated in 2016-11-11&lt;/p&gt;
&lt;p&gt;为了深入了解 R 语言，谷歌检索了阅读源代码的方法，在此整理和记录以便往后查阅。要直接从 R 命令行获取源代码，需要了解一些 R 语言编程知识。R 语言中函数或者方
    
    </summary>
    
      <category term="Notes" scheme="blog.alexiangli.com/categories/Notes/"/>
    
    
      <category term="R" scheme="blog.alexiangli.com/tags/R/"/>
    
      <category term="R-basics" scheme="blog.alexiangli.com/tags/R-basics/"/>
    
  </entry>
  
  <entry>
    <title>R：正则表达式</title>
    <link href="blog.alexiangli.com/r-regex/"/>
    <id>blog.alexiangli.com/r-regex/</id>
    <published>2016-10-02T16:46:15.000Z</published>
    <updated>2016-11-19T03:29:10.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>A ‘regular expression’ is a pattern that describes a set of strings.</p>
</blockquote>
<p>按照文档中的定义，正则表达式是用来描述一个字符串集合的模式（pattern）。<br>
在 R 语言中，有两类正则表达式：一是默认使用的拓展的正则表达式（extended regular expressions）；二是类 Perl 语言的正则表达式，通过 <code>perl = TRUE</code> 生效。另外还有可以通过设置参数 <code>fixed = TRUE</code> 使用 literal 正则表达式。<br>
支持正则表达式的函数包括：<code>grep</code> <code>grepl</code> <code>regexpr</code> <code>gregexpr</code> <code>sub</code> <code>gsub</code> <code>strsplit</code>。其他函数 <code>apropos</code> <code>browseEnv</code> <code>help.search</code> <code>list.files</code> <code>ls</code> 等往往通过 <code>grep</code> 函数来支持正则表达式。<br>
正则表达式过长可能不被接受，因为 POSIX 标准仅支持最高256字节。</p>
<h1 id="extended-regular-expressions">Extended Regular Expressions</h1>
<ul>
<li>字母和数字本身就是正则表达式，可用来匹配自身。</li>
<li>具有特殊含义的元字符需要通过反斜杠（backslash，<code>\</code>）逃逸其所代表的特殊含义。</li>
</ul>
<p>元字符包括：<code>. \ | ( ) [ { ^ $ * + ?</code></p>
<blockquote>
<p>Escaping non-metacharacters with a backslash is implementation-dependent. The current implementation interprets \a as BEL, \e as ESC, \f as FF, \n as LF, \r as CR and \t as TAB.<br>
A character class is a list of characters enclosed between [ and ] which matches any single character in that list; unless the first character of the list is the caret ^, when it matches any character not in the list.<br>
A range of characters may be specified by giving the first and last characters, separated by a hyphen.<br>
Certain named classes of characters are predefined. Their interpretation depends on the locale (see locales); the interpretation below is that of the POSIX locale.</p>
</blockquote>
<p><code>[:alnum:]</code> = <code>[:alpha:]</code> + <code>[:digit:]</code><br>
<code>[:alpha:]</code> = <code>[:lower:]</code> + <code>[:upper:]</code><br>
<code>[:blank:]</code> 空白符，如空格、tab<br>
<code>[:cntrl:]</code> Control characters<br>
<code>[:digit:]</code> 数字<br>
<code>[:graph:]</code> = <code>[:alnum:]</code> + <code>[:punct:]</code><br>
<code>[:lower:]</code> 小写字母<br>
<code>[:print:]</code> 可打印的字符 <code>[:alnum:]</code> <code>[:punct:]</code> 空格<br>
<code>[:punct:]</code> 标点符号<br>
<code>[:space:]</code> 空格符：tab, newline, vertical tab, form feed, carriage return, space, and possibly other locale-dependent characters<br>
<code>[:upper:]</code> 大写字母<br>
<code>[:xdigit:]</code> 十六进制数字</p>
<p>元字符</p>
<p><code>.</code> 匹配其他任何单字符<br>
<code>\w</code> 匹配单词 = <code>[[:alnum:]_]</code> <code>\W</code> = <code>[^[:alnum:]_]</code><br>
<code>\s</code> 空白符 <code>\S</code> 非空白符<br>
<code>\d</code> 数字 <code>\D</code> 非数字<br>
<code>^</code> 匹配首空字符（line）<br>
<code>$</code> 匹配尾空字符（line）<br>
<code>\&lt;</code> 匹配首空字符（word）<br>
<code>\&gt;</code> 匹配尾空字符（word）<br>
<code>\b</code> 匹配位于边缘的空字符（word）<br>
<code>\B</code> 匹配非边缘字符（word）</p>
<p>匹配频率有关的元字符</p>
<p><code>?</code> 匹配 1 次<br>
<code>*</code> 匹配 0 或多次<br>
<code>+</code> 匹配 1 或多次<br>
<code>{n}</code> 匹配 n 次<br>
<code>{n,}</code> 匹配 n 或更多次<br>
<code>{n,m}</code> 匹配 n 至 m 次</p>
<p>默认来说，默认匹配次数是有多少次就多少次。但是可以通过 <code>?</code> 来改变低频率匹配。<br>
正则表达式可以被连接起来，其作用等同于把待匹配的字符串用连接的正则表达式匹配的效果。两个正则表达式也可以通过 <code>|</code> 求并集。</p>
<h1 id="正则表达式函数实例">正则表达式函数实例</h1>
<h2 id="grep">grep</h2>
<hr>
<p>未完待续</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;A ‘regular expression’ is a pattern that describes a set of strings.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;按照文档中的定义，正则表达式是用来描述一个字符串集合的模式（patt
    
    </summary>
    
      <category term="Original" scheme="blog.alexiangli.com/categories/Original/"/>
    
    
      <category term="R" scheme="blog.alexiangli.com/tags/R/"/>
    
      <category term="正则表达式" scheme="blog.alexiangli.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>PHP 安装与配置</title>
    <link href="blog.alexiangli.com/php-config/"/>
    <id>blog.alexiangli.com/php-config/</id>
    <published>2016-09-25T13:00:45.000Z</published>
    <updated>2016-11-28T12:44:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>为了了解 PHP 这门所谓的“世界上最好的语言”，特意安装和配置了 PHP 环境。</p>
<p>因为系统是 Mac OSX，所以直接使用 <code>brew install php56</code> 来安装。但是并未找到 php56 。于是 <code>brew search php</code>，发现 php 相关安装包位于 <code>/homebrew/php/*</code>，于是用 <code>brew install homebrew/php/php56</code> 安装。但是出现报错 <code>undefined method rebuild</code> 的错误。尝试 <code>brew cleanup &amp;&amp; brew update</code>，仍然不起作用，依旧报错。后来查询到可以更新下 homebrew 的仓库。于是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cd $(brew --repo)</div><div class="line">git fetch</div><div class="line">git reset --hard origin/master</div><div class="line">brew update</div></pre></td></tr></table></figure>
<p>然后再尝试安装 <code>brew install homebrew/php/php56</code>。</p>
<p>其实也可以这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">brew tap homebrew/dupes</div><div class="line">brew tap homebrew/versions</div><div class="line">brew tap homebrew/homebrew-php</div><div class="line">brew install php56</div></pre></td></tr></table></figure>
<p>然后安装了包管理工具 composer</p>
<blockquote>
<p>PHP 世界的包管理工具Composer</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install homebrew/php/composer</div></pre></td></tr></table></figure>
<p>并且安装了 psySH</p>
<blockquote>
<p>A runtime developer console, interactive debugger and REPL for PHP.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">composer g require psy/psysh:@stable</div></pre></td></tr></table></figure>
<p>psySH 的二进制文件位于 <code>~/.composer/vendor/psysh</code><br>
也可以通过这个来运行 <code>~/.composer/vendor/bin/psysh</code><br>
为了方便，我将其添加到 PATH <code>export $PATH:/Users/lix/.composer/vendor/bin</code></p>
<p>配置 emacs 的 php 环境<br>
先安装 ac-php 的依赖 <code>brew install cscope</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">;;; php mode</div><div class="line">(use-package php-mode</div><div class="line">  :ensure t</div><div class="line">  :mode &quot;\\.php\\&apos;&quot;</div><div class="line">  :config</div><div class="line">  (progn</div><div class="line">    (add-hook &apos;php-mode-hook &apos;smartparens-mode)</div><div class="line">    (use-package ac-php</div><div class="line">      :ensure t</div><div class="line">      :config</div><div class="line">      (add-hook &apos;php-mode-hook</div><div class="line">                &apos;(lambda ()</div><div class="line">                   (use-package company-php :ensure t)</div><div class="line">                   (company-mode t)</div><div class="line">                   (add-to-list &apos;company-backends &apos;company-ac-php-backend))))</div><div class="line">    (use-package php-eldoc</div><div class="line">      :ensure t</div><div class="line">      :config</div><div class="line">      (add-hook &apos;php-mode-hook &apos;php-eldoc-enable))))</div><div class="line"></div><div class="line">;;; php REPL</div><div class="line">(use-package psysh</div><div class="line">  :if (executable-find &quot;psysh&quot;)</div><div class="line">  :ensure t</div><div class="line">  :defer t</div><div class="line">  :config</div><div class="line">  (add-hook &apos;psysh-mode-hook &apos;smartparens-mode))</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了了解 PHP 这门所谓的“世界上最好的语言”，特意安装和配置了 PHP 环境。&lt;/p&gt;
&lt;p&gt;因为系统是 Mac OSX，所以直接使用 &lt;code&gt;brew install php56&lt;/code&gt; 来安装。但是并未找到 php56 。于是 &lt;code&gt;brew sea
    
    </summary>
    
      <category term="Original" scheme="blog.alexiangli.com/categories/Original/"/>
    
      <category term="Config" scheme="blog.alexiangli.com/categories/Original/Config/"/>
    
    
      <category term="PHP" scheme="blog.alexiangli.com/tags/PHP/"/>
    
      <category term="Configuration" scheme="blog.alexiangli.com/tags/Configuration/"/>
    
  </entry>
  
  <entry>
    <title>从零学机器学习之决策树</title>
    <link href="blog.alexiangli.com/ml-decision-tree/"/>
    <id>blog.alexiangli.com/ml-decision-tree/</id>
    <published>2016-09-22T02:10:09.000Z</published>
    <updated>2016-11-28T12:43:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>以一名数学只有普通高中水平的非理工科人的视角尝试理解机器学习之<strong>决策树</strong>。</p>
<p>决策树是一种比较好理解的分类算法，望文就能生意，而且意思还不会出现大的偏差。把这个算法的过程想像成一棵树或者根毛的生长过程，决策层越低，分支越丰富。决策树的优点之一也就在于此，容易理解，像我这样的非专业领域的人可以直接脑补。</p>
<p>《机器学习实战》这本书中描述，决策树的 <strong>计算复杂度</strong> 不高，输出结果易于理解（可以用直观来理解），对 <strong>中间值</strong> 的缺失不敏感（这里没懂，中间值是啥？），可以处理不相关特征数据（对数据要求不严格？）。但是，决策树虽简单，但容易产生过度匹配问题。为什么会产生过度匹配问题呢？也许是因为分类的标准太“粗糙”或者“武断”吧？？？。其适用数据类型包括 <strong>数值型</strong> 和 <strong>标称型</strong>。</p>
<p>决策树是通过对数据集的特征按照某种标准进行分类，分成若干个子数据集，子数据集又可以按照新的标准对子数据集进行分类。这里有个疑问，到底要分多少次呢？明白了，如果“决策”次数越多，决策树模型越复杂，模型越复杂，是不是就计算复杂度越高呢？这个又与“过度拟合”有关吗？直觉去看，一个数据集可以有许多特征，但是有些特征对分类并无太大的作用。举个例子，把人和动物进行区分，到底是“使用和制造工具的能力”还是“语言”？对决策树就是这样一个过程。挑选出最能够区分出类别的一批特征，然后对数据集进行分类。这样模型简单，精确度又越高。但是如何知道哪些特征最合适呢？<s>这就需要先验知识了，这里头就有了人为性。所以从这里也可以知道，决策树是一个监督学习。</s> 看到知乎里头一个问题 <a href="https://www.zhihu.com/question/19753084" target="_blank" rel="external">信息增益到底怎么理解呢？</a>，明白了，原来可以用 <strong>信息增益</strong> 来确定一个特征用于分类是不是合适。</p>
<p>前面说到，决策树适用的数据类型包括了 <strong>数值型</strong>，但是，<strong>树构造算法只适用于标称型数据，数值型数据必须离散化</strong>。也就是说，要用“身高”和“体重”来区分男女，必须把这两个数值型数据转化为离散的，例如 <code>&gt;170cm</code>，<code>&lt;170cm</code>，体重 <code>&gt;60kg</code>，<code>&lt;60kg</code>。或者稍微精细一点，按照 10cm 和 5kg 的精度进行分割。</p>
<p>阅读《机器学习实战》的过程中，有个概念很抽象，<strong>信息增益</strong>。我尝试去这样理解。如果没有 <strong>生物分类学</strong>，人对物种的认识和理解是杂乱的，可能每个人的主观分类都不一致，因为不同人关注于不同特征。但有了一个分类系统，本来看似乱套的系统，就有了规律，这样就有了标准，形成了可以共享的知识。在这里 “信息” 就是 “不同的生物”，“增益” 就是促进了对生物物种的认识，产生了可以交流和分享的知识。看起来，<strong>信息增益</strong> 是一个褒义词呀，信息增益越高越好。那怎么量化信息增益呢？这里又出现一个更加抽象难以理解的概念 <strong>熵</strong>。最开始见到这个词的时候，我竟担心自己读错。所以，顿时发现，隔行如隔山的罪魁祸首之一就是这些该死的专业术语了。越专业越不好好说话。不过，命名一些专业术语把知识简化，也是为了本专业内沟通的效率吧（活学活用，提高信息增益）。</p>
<p>那么什么是 <strong>信息熵</strong>？看定义，熵为信息的期望值（期望值即平均值，高中数学的水平，平均值对我来说比较好理解）。在文科生眼里，<strong>信息</strong> 用公式定义真是碉堡了。好了，不想数学公式了。总之，这里把信息当作概率去看待了。我只想明白，熵的大小意味着什么。维基百科的信息熵词条里有几句话：1. 熵最好理解为不确定性的度量而不是确定性的度量，因为越随机的信源的熵越大；2. 比较不可能发生的事情，当它发生了，会提供更多的信息。拿自己所知道的一点点背景知识理解的话，也就是小概率事件发生了，熵就变大了，熵变大了，事情就越发不可预测了，因为越随机了。也就是说，我越懵逼，熵就越大？这个世界乱成一团遭，那么熵就越大了。看来，<strong>熵</strong> 是个贬义词呀，哈哈。像那些信息量大的话，还是不说为好，毕竟熵大，有些人难以理解，毕竟不是所有人都有那么有内涵。那么用熵来量化信息增益，就是，熵变得越小，信息增益就越大。我们为的把世界看清楚，就得让熵变小。但是现实很残酷，我们无法预测未来，熵是不以我们的意志为转移的，该死的熵跟房价一样，死也降不下来啊。不过提高自身实力，认清自我，未来就不那么迷茫了，重要的是脚踏实地嘛。熵自然而然就小了。好吧，扯远了。总之，熵和信息增益是个对立的关系。</p>
<hr>
<p>待续</p>
<hr>
<p>参考资料：</p>
<ul>
<li>《机器学习实战》</li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%86%B5_(%E4%BF%A1%E6%81%AF%E8%AE%BA)" target="_blank" rel="external">熵 (信息论)</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以一名数学只有普通高中水平的非理工科人的视角尝试理解机器学习之&lt;strong&gt;决策树&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;决策树是一种比较好理解的分类算法，望文就能生意，而且意思还不会出现大的偏差。把这个算法的过程想像成一棵树或者根毛的生长过程，决策层越低，分支越丰富。决策树
    
    </summary>
    
      <category term="Original" scheme="blog.alexiangli.com/categories/Original/"/>
    
      <category term="Data science" scheme="blog.alexiangli.com/categories/Original/Data-science/"/>
    
    
      <category term="Machine learning" scheme="blog.alexiangli.com/tags/Machine-learning/"/>
    
      <category term="Decision tree" scheme="blog.alexiangli.com/tags/Decision-tree/"/>
    
      <category term="Data science" scheme="blog.alexiangli.com/tags/Data-science/"/>
    
  </entry>
  
  <entry>
    <title>零基础如何学习一门新的编程语言？</title>
    <link href="blog.alexiangli.com/learn-new-programming-language/"/>
    <id>blog.alexiangli.com/learn-new-programming-language/</id>
    <published>2016-09-17T06:48:43.000Z</published>
    <updated>2016-11-28T12:43:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>在正式读研之前，我几乎没有编程基础。本科在一所不知名的民办二本院校的第一届人力资源班。只在省二级计算机考试中接触了丁点儿编程（好像是VFOX）。也没有考国家计算机二级证书。从刚读研开始，需要在 MATLAB 环境下工作，才正式学起了一门程序语言。所以学习一门编程语言并没有想象中的困难。</p>
<p>借这个地儿，分享<strong>如何从零基础菜鸟开始入门到熟悉并且掌握一门程序语言</strong>的一些经验，希望能够给同样零基础，或者畏惧编程的朋友（特别是从事科学研究的人）一些启发。</p>
<p>P.S. 内容较为简洁，后续再补充。</p>
<h1 id="为什么科研人员要至少学一门编程语言？">为什么科研人员要至少学一门编程语言？</h1>
<ul>
<li>提高生产效率（productivity）</li>
<li>培养抽象逻辑思维（abstract thinking）</li>
<li>提高研究的可重复性，拥抱开放科学（<a href="https://en.wikipedia.org/wiki/Open_science" target="_blank" rel="external">open science</a>）</li>
<li>促进同行交流（communication）</li>
<li>…</li>
</ul>
<h1 id="对于科研工作者有哪些编程语言和工具值得一学？">对于科研工作者有哪些编程语言和工具值得一学？</h1>
<ul>
<li><code>R</code> <code>Python</code> <code>Matlab</code></li>
<li><code>Linux</code> <code>Shell</code> <code>Git</code></li>
</ul>
<p>为什么要学习这些东西，搜索引擎检索：<code>why learn x as y</code> 或者 <code>Y 为什么学 X</code>，X 为对应的语言和工具，Y 为职业或者领域。</p>
<hr>
<h1 id="准备工作">准备工作</h1>
<h2 id="1-科学上网">1. 科学上网</h2>
<p><a href="https://zh.wikipedia.org/zh/%E9%98%B2%E7%81%AB%E9%95%BF%E5%9F%8E" target="_blank" rel="external">GFW</a> 阻断了国人许多获取信息和知识的渠道。所以，要想借助互联网进行学习，首要解决的问题就是突破 GFW 的限制。</p>
<ul>
<li>Chrome/Firefox: 请用帐号登录浏览器，已便于同步书签；若希望跨浏览器同步书签，请使用搜索引擎检索“跨浏览器同步书签”</li>
<li><a href="https://shadowsocks.com/client.html" target="_blank" rel="external">shadowsocks</a>，请从网上获取免费或者付费帐号，不会使用请检索“如何使用shadowsocks科学上网”</li>
</ul>
<h2 id="2-环境配置">2. 环境配置</h2>
<p>要想舒服的学习程序语言，那么就要配置舒服的语言环境。就好像，学外语一样，得有一个很好的语言环境，学习起来才自然。初学者一定不要忽视编程环境的重要性，一定要让自己舒舒服服地写代码，编程的过程才不是枯燥乏味的，惹人烦的。所以，一定要扎扎实实把环境给配置好了，再开始系统地学。如果在进行配置上有困难，那就请教其他懂行的人，或者再多花一些时间。如果仅仅是在面对环境的配置就进行不下去了，那的确可以不用学编程了。</p>
<p>配置语言环境从以下三个方面进行。</p>
<ul>
<li>操作系统
<ul>
<li>Ubuntu</li>
<li>MacOS</li>
<li>Windows 下虚拟机运行 Ubuntu</li>
<li>（Windows 下进行配置本人没有尝试过）</li>
</ul>
</li>
<li>编辑器
<ul>
<li>较容易：<a href="https://www.sublimetext.com/" target="_blank" rel="external">Sublime Text</a>，<a href="https://atom.io/" target="_blank" rel="external">Atom</a></li>
<li>较难：<a href="https://www.gnu.org/software/emacs/" target="_blank" rel="external">Emacs</a>，<a href="http://www.vim.org/" target="_blank" rel="external">Vim</a></li>
</ul>
</li>
<li>集成开发环境 IDE (Integrated development environment)
<ul>
<li>R: <a href="https://www.rstudio.com/" target="_blank" rel="external">Rstudio</a>, Emacs (ESS)</li>
<li>Python: <a href="https://ipython.org/" target="_blank" rel="external">IPython</a>, <a href="https://github.com/spyder-ide/spyder" target="_blank" rel="external">Spyder</a>, <a href="https://www.continuum.io/downloads" target="_blank" rel="external">Anaconda</a>, Emacs (Elpy)</li>
<li>Matlab: Matlab GUI, Emacs (matlab-mode)</li>
</ul>
</li>
</ul>
<hr>
<h1 id="学习资料">学习资料</h1>
<h2 id="1-官方文档-documentations">1. 官方文档 Documentations</h2>
<ul>
<li><a href="https://www.r-project.org/" target="_blank" rel="external">R</a>, <a href="https://support.rstudio.com/hc/en-us/categories/200035113-Documentation" target="_blank" rel="external">Rstudio</a>, <a href="http://www.rdocumentation.org/" target="_blank" rel="external">Rdocumentation</a>, <a href="http://rseek.org/" target="_blank" rel="external">Rseek</a>,</li>
<li><a href="http://docs.python.org/2/" target="_blank" rel="external">Python2.x</a>, <a href="http://docs.python.org/3/" target="_blank" rel="external">Python3.x</a></li>
<li><a href="http://cn.mathworks.com/help/" target="_blank" rel="external">Matlab Documentation</a></li>
</ul>
<h2 id="2-搜索引擎-search-engines">2. 搜索引擎 Search Engines</h2>
<ul>
<li><strong>Google Search</strong>：<a href="https://www.zhihu.com/question/20161362" target="_blank" rel="external">谷歌学术检索技巧</a></li>
<li>DuckDuckGo</li>
<li>Bing</li>
<li>Baidu</li>
</ul>
<h2 id="3-社区-community">3. 社区 Community</h2>
<ul>
<li>综合：<a href="https://github.com/" target="_blank" rel="external">Github</a>, <a href="http://stackoverflow.com/" target="_blank" rel="external">StackOverflow</a></li>
<li>R: <a href="http://cos.name/" target="_blank" rel="external">统计之都</a>, <a href="https://www.r-bloggers.com/" target="_blank" rel="external">R-bloggers</a>, <a href="https://github.com/qinwf/awesome-R" target="_blank" rel="external">Awesome-R</a></li>
<li>Python: <a href="http://python-china.org/" target="_blank" rel="external">Python China</a>, <a href="https://github.com/vinta/awesome-python" target="_blank" rel="external">Awesome-Python</a></li>
<li>MATLAB: <a href="http://www.mathworks.com/matlabcentral/fileexchange/" target="_blank" rel="external">File Exchange</a>, <a href="http://cn.mathworks.com/matlabcentral/answers/index" target="_blank" rel="external">MATLAB Answers</a> <a href="https://github.com/mikecroucher/awesome-MATLAB" target="_blank" rel="external">Awesome-MATLAB</a></li>
</ul>
<h2 id="4-练习项目-toy-projects">4. 练习项目 Toy Projects</h2>
<ul>
<li>个人研究项目</li>
<li>网上公开项目（去 Google 检索或者直接去 Github 搜）</li>
</ul>
<p>需要提及的是，R 语言有一个公益项目 <a href="https://github.com/swirldev/swirl" target="_blank" rel="external">Swirl</a> 可以在 R 的命令窗口通过交互式的方式学习 R。具体请查看 Swirl 的相关文档介绍。</p>
<h2 id="5-书籍-books">5. 书籍 Books</h2>
<p>准备两三本书来系统地了解一门编程语言。网上有许多免费书籍，请看 <strong>其他线上学习资料</strong>。</p>
<h2 id="6-其他线上学习资料-待更新">6. 其他线上学习资料（待更新）</h2>
<p>前面提到的 <code>Awesome</code> 项目已经囊括了各种编程语言和其他领域的学习资源，这里仅仅提一些我看过的。</p>
<ul>
<li>General: <a href="http://programming-motherfucker.com/become.html" target="_blank" rel="external">Become a Programmer, Motherfucker</a></li>
<li>R: <a href="http://www.cookbook-r.com/" target="_blank" rel="external">Cookbook for R</a>，<a href="http://adv-r.had.co.nz/" target="_blank" rel="external">Advanced R</a>，<a href="https://csgillespie.github.io/efficientR/" target="_blank" rel="external">Efficient R programming</a>, <a href="http://health.adelaide.edu.au/psychology/ccs/teaching/lsr/" target="_blank" rel="external">Learning Statistics with R</a>,<a href="http://r4ds.had.co.nz/" target="_blank" rel="external">R for Data Science</a>, <a href="http://www.psych.upenn.edu/~baron/rpsych/rpsych.html" target="_blank" rel="external">Notes on the use of R for psychology experiments and questionnaires</a></li>
<li>Python: <a href="http://codingpy.com/books/thinkpython2/index.html" target="_blank" rel="external">Think Python 第二版</a>, <a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/index.html" target="_blank" rel="external">Python Cookbook 第三版</a>, <a href="http://gael-varoquaux.info/stats_in_python_tutorial/" target="_blank" rel="external">Statistics in Python</a></li>
<li>MATLAB：<a href="http://mirlab.org/jang/books/matlabProgramming4beginner/" target="_blank" rel="external">MATLAB程式設計：入門篇</a>，<a href="http://mirlab.org/jang/books/matlabProgramming4guru/" target="_blank" rel="external">MATLAB程式設計：進階篇</a>，<a href="http://www.matlab-cookbook.com/" target="_blank" rel="external">MATLAB Cookbook</a></li>
</ul>
<hr>
<h1 id="如何学习">如何学习</h1>
<h2 id="第一步：从整体上了解某种语言功能-特点以及优缺点">第一步：从整体上了解某种语言功能、特点以及优缺点</h2>
<p>这一步可以通过慕课或者书籍来对一门编程语言有一个大概的了解，知道它适合做什么，不适合做什么。</p>
<p>相关慕课请通过搜索引擎进行检索。个人不太喜欢看视频学一门编程语言，相对来说比较喜欢看书。习惯看电子书的可以访问前面提到的免费电子书。习惯看纸质书的借一本翻翻就行了。也许其他人比较喜欢看视频教学。</p>
<h2 id="第二步：弄明白如何查询和获取帮助文档-getting-help">第二步：弄明白如何查询和获取帮助文档 Getting Help</h2>
<p>以下是一些获取帮助的命令，先熟练这几个命令的用法，对后面学习其他函数和命令有非常大的帮助。并不是任何时候都需要查谷歌搜百度。通过这些命令也可以对相关编程语言进行学习。</p>
<ul>
<li>R: <code>?function</code> <code>help(function)</code> <code>help.search()</code> <code>apropos()</code></li>
<li>Python: <code>?</code> <code>??</code> <code>help()</code> <code>dir()</code> <code>__doc__</code></li>
<li>Matlab: <code>help</code> <code>doc</code> <code>lookfor</code></li>
</ul>
<h2 id="第三步：熟悉基本语法和编码规范-grammar-style">第三步：熟悉基本语法和编码规范 Grammar &amp; Style</h2>
<ul>
<li><a href="https://learnxinyminutes.com/" target="_blank" rel="external">Learn X in Y Minutes</a>
<ul>
<li><a href="https://learnxinyminutes.com/docs/zh-cn/r-cn/" target="_blank" rel="external">X 分钟速成 R</a></li>
<li><a href="https://learnxinyminutes.com/docs/zh-cn/python-cn/" target="_blank" rel="external">X 分钟速成 Python</a></li>
<li><a href="https://learnxinyminutes.com/docs/zh-cn/matlab-cn/" target="_blank" rel="external">X 分钟速成 MATLAB</a></li>
</ul>
</li>
<li>通过 <strong>Cheat Sheet</strong> 来快速了解基本语法
<ul>
<li><a href="https://www.cheatography.com/" target="_blank" rel="external">Cheatography</a></li>
<li><a href="http://www.cheat-sheets.org/" target="_blank" rel="external">Cheat-Sheets.org</a></li>
<li>或者谷歌检索 <code>cheat sheet r/python/matlab filetype:pdf</code> 或者 <code>quick reference r/python/matlab filetype:pdf</code></li>
</ul>
</li>
<li>代码规范 Coding Style
<ul>
<li>R: <a href="https://google.github.io/styleguide/Rguide.xml" target="_blank" rel="external">Google’s R Style Guide</a>, <a href="http://adv-r.had.co.nz/Style.html" target="_blank" rel="external">R Style guide</a></li>
<li>Python: <a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="external">PEP 8 – Style Guide for Python Code</a>, <a href="https://google.github.io/styleguide/pyguide.html" target="_blank" rel="external">Google Python Style Guide</a></li>
<li>MATLAB: <a href="https://cn.mathworks.com/matlabcentral/fileexchange/46056-matlab-style-guidelines-2-0" target="_blank" rel="external">MATLAB Style Guidelines 2.0</a>, <a href="www.cs.cornell.edu/courses/cs321/2003fa/Matlab%20Coding%20Style.pdf">Matlab Coding Style</a></li>
</ul>
</li>
</ul>
<h2 id="第四步：在练习或实践中探索性地学习-practice-experimentation">第四步：在练习或实践中探索性地学习 Practice &amp; Experimentation</h2>
<p>在学习和使用编程语言的过程中，不可避免的遇到各种报错信息。这并不是不好的信号，而正式掌握一个函数或者语法时候。有时候可以故意“犯错”，看看出现什么样的报错信息。总之，多去根据文档里头的例子或者自己编个例子尝试尝试一个函数的用法。</p>
<h2 id="第五步：阅读书籍和源码-books-source-code">第五步：阅读书籍和源码 Books &amp; Source code</h2>
<p>一般来说，不做程序员，就没必要学得太深入。但是如果感兴趣，要进一步提高，那就要多阅读经典技术书籍和源代码咯。</p>
<hr>
<h1 id="linux-shell-git-学习资源">Linux, Shell, &amp; Git 学习资源</h1>
<p>Linux</p>
<ul>
<li><a href="http://linux.vbird.org/linux_basic/" target="_blank" rel="external">鸟哥的 Linux 私房菜</a></li>
<li><a href="https://github.com/aleksandar-todorovic/awesome-linux" target="_blank" rel="external">Awesome Linux</a></li>
</ul>
<p>Shell</p>
<ul>
<li><a href="http://billie66.github.io/TLCL/index.html" target="_blank" rel="external">快乐的 Linux 命令行</a></li>
<li><a href="https://github.com/alebcay/awesome-shell" target="_blank" rel="external">Awesome Shell</a></li>
</ul>
<p>Git</p>
<ul>
<li><a href="https://git-scm.com/documentation" target="_blank" rel="external">Git Documentation</a></li>
<li><a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="external">Git 简明指南</a></li>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰的 Git 教程</a></li>
</ul>
<hr>
<h1 id="总结">总结</h1>
<ul>
<li>在科学上网的前提下，善用<strong>搜索引擎</strong>；</li>
<li>学会查询和阅读<strong>文档</strong>；</li>
<li>在最开始就养成良好的<strong>编程规范</strong>；</li>
<li>探索性地<strong>边做边学</strong>。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在正式读研之前，我几乎没有编程基础。本科在一所不知名的民办二本院校的第一届人力资源班。只在省二级计算机考试中接触了丁点儿编程（好像是VFOX）。也没有考国家计算机二级证书。从刚读研开始，需要在 MATLAB 环境下工作，才正式学起了一门程序语言。所以学习一门编程语言并没有想
    
    </summary>
    
      <category term="Original" scheme="blog.alexiangli.com/categories/Original/"/>
    
      <category term="Learning" scheme="blog.alexiangli.com/categories/Original/Learning/"/>
    
    
      <category term="Programming" scheme="blog.alexiangli.com/tags/Programming/"/>
    
      <category term="How-to-learn" scheme="blog.alexiangli.com/tags/How-to-learn/"/>
    
  </entry>
  
  <entry>
    <title>SQL 语言入门笔记</title>
    <link href="blog.alexiangli.com/sql-intro/"/>
    <id>blog.alexiangli.com/sql-intro/</id>
    <published>2016-09-17T01:46:39.000Z</published>
    <updated>2017-07-07T07:14:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>《数据库系统概论》第三章笔记。</p>
<h1 id="基础">基础</h1>
<h2 id="sql-历史">SQL 历史</h2>
<ul>
<li>1974 年，Boyce 和 Chamberlin 提出，Sequel</li>
<li>1986 年 10 月，美国国家标准局（ANSI）的数据库委员会 X3H2 批准，同年公布 SQL 标准文本</li>
<li>1987 年，国际化标准组织（ISO）通过这一标准</li>
</ul>
<p>没有一个数据库系统能够支持 SQL 标准的所有概念和特性。许多软件厂商对 SQL 的基本命令集进行了不同程度的扩充和修改，又可以支持标准以外的一些功能特性。</p>
<h2 id="sql-特点">SQL 特点</h2>
<ul>
<li>综合统一
<ul>
<li>SQL 集 <code>数据定义语言</code>、<code>数据操纵语言</code>、<code>数据控制语言</code> 的功能于一体，可以独立完成数据库生命周期中的全部活动。
<ul>
<li>定义和修改、删除关系模式，定义和删除视图，插入数据，建立数据库；</li>
<li>对数据库中的数据进行查询和更新；</li>
<li>数据库重构和维护；</li>
<li>数据库安全性、完整性控制，以及事务控制；</li>
<li>嵌入式 SQL 和动态 SQL 定义。</li>
</ul>
</li>
</ul>
</li>
<li>高度非过程化</li>
<li>面向集合的操作方式</li>
<li>以同一种语法结构提供多种使用方式
<ul>
<li>既是独立语言，又是嵌入式语言</li>
</ul>
</li>
<li>语言简洁，易学易用</li>
</ul>
<h2 id="sql-基本概念">SQL 基本概念</h2>
<p>三级模式结构</p>
<ul>
<li>外模式：若干视图、部分基本表</li>
<li>模式：若干基本表</li>
<li>内模式：若干存储文件</li>
</ul>
<hr>
<h1 id="数据定义">数据定义</h1>
<h2 id="模式的定义与删除">模式的定义与删除</h2>
<h3 id="1-定义模式">1. 定义模式</h3>
<p><code>CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt;</code></p>
<p>进行该操作需具备数据库管理员权限，或者获得了数据库管理员授予的 CREATE SCHEMA 的权限。</p>
<p>定义模式实际上定义了一个命名空间，在此可以进一步定义该模式包含的数据库对象。</p>
<p><code>CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt; [&lt;表定义子句&gt;|&lt;视图定义子句&gt;|&lt;授权定义子句&gt;]</code></p>
<h3 id="2-删除模式">2. 删除模式</h3>
<p><code>DROP SCHEMA &lt;模式名&gt;&lt;CASCADE|RESTRICT&gt;</code></p>
<ul>
<li><code>CASCADE</code> 级联，表示在删除模式时把该模式中所有的数据库对象全部删除；</li>
<li><code>RESTRICT</code> 限制，表示如果该模式中定义了下属的数据库对象（如表或视图），则拒绝该删除语句的执行。</li>
</ul>
<h2 id="基本表的定义-删除与修改">基本表的定义、删除与修改</h2>
<h3 id="1-定义基本表">1. 定义基本表</h3>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> &lt;表名&gt;</div><div class="line">    (&lt;列名&gt;&lt;数据类型&gt; [列级完整性约束条件]</div><div class="line">    [,&lt;列名&gt;&lt;数据类型&gt; [列级完整性约束条件]]</div><div class="line">    ...</div><div class="line">    [,&lt;表级完整性约束条件&gt;]);</div></pre></td></tr></table></figure>
<h3 id="2-数据类型">2. 数据类型</h3>
<p>在 SQL 中域的概念用数据类型来实现。定义表的各个属性时需要指明其数据类型及长度。选择数据类型从两方面考虑，一是取值范围，二是要做哪些运算。</p>
<table>
<thead>
<tr>
<th style="text-align:left">数据类型</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>CHAR(n)</code>,<code>CHARACTER(n)</code></td>
<td style="text-align:left">长度为 n 的定长字符串</td>
</tr>
<tr>
<td style="text-align:left"><code>VARCHAR(n)</code>,<code>CHARACTERVARYING(n)</code></td>
<td style="text-align:left">最大长度为 n 的变长字符串</td>
</tr>
<tr>
<td style="text-align:left"><code>CLOB</code></td>
<td style="text-align:left">字符串大对象</td>
</tr>
<tr>
<td style="text-align:left"><code>BLOB</code></td>
<td style="text-align:left">二进制大对象</td>
</tr>
<tr>
<td style="text-align:left"><code>INT</code>,<code>INTEGER</code></td>
<td style="text-align:left">长整数（4字节）</td>
</tr>
<tr>
<td style="text-align:left"><code>SMALLINT</code></td>
<td style="text-align:left">短整数（2字节）</td>
</tr>
<tr>
<td style="text-align:left"><code>BIGINT</code></td>
<td style="text-align:left">大整数（8字节）</td>
</tr>
<tr>
<td style="text-align:left"><code>NUMERIC(p,d)</code></td>
<td style="text-align:left">定点数，由 p 位数字（不包括符号、小数点）组成，小数点后面有 d 位数字</td>
</tr>
<tr>
<td style="text-align:left"><code>DECIMAL(p,d)</code>,<code>DEC(p,d)</code></td>
<td style="text-align:left">同 NUMERIC</td>
</tr>
<tr>
<td style="text-align:left"><code>REAL</code></td>
<td style="text-align:left">取决于机器精度的单精度浮点数</td>
</tr>
<tr>
<td style="text-align:left"><code>DOUBLE PRECISION</code></td>
<td style="text-align:left">取决于机器精度的双精度浮点数</td>
</tr>
<tr>
<td style="text-align:left"><code>FLOAT(n)</code></td>
<td style="text-align:left">可选精度的浮点数，精度至少位 n 位数字</td>
</tr>
<tr>
<td style="text-align:left"><code>BOOLEAN</code></td>
<td style="text-align:left">逻辑布尔量</td>
</tr>
<tr>
<td style="text-align:left"><code>DATE</code></td>
<td style="text-align:left">日期，包含年、月、日，格式为 YYYY-MM-DD</td>
</tr>
<tr>
<td style="text-align:left"><code>TIME</code></td>
<td style="text-align:left">时间，包含一日的时、分、秒，格式为 HH:MM:SS</td>
</tr>
<tr>
<td style="text-align:left"><code>TIMESTAMP</code></td>
<td style="text-align:left">时间戳类型</td>
</tr>
<tr>
<td style="text-align:left"><code>INTERVAL</code></td>
<td style="text-align:left">时间间隔类型</td>
</tr>
</tbody>
</table>
<h3 id="3-模式与表">3. 模式与表</h3>
<p>三种方法定义基本表所属的模式：</p>
<ol>
<li>在表名中明显地给出模式名；</li>
<li>在创建模式语句中同时创建表；</li>
<li>设置所属的模式，这样在创建表时表名中不必给出模式名。</li>
</ol>
<p>显示当前搜索路径：<code>SHOW search_path</code>;<br>
设置搜索路径：<code>SET search_path &lt;模式名&gt;,PUBLIC</code>;</p>
<h3 id="4-修改基本表">4. 修改基本表</h3>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt;</div><div class="line">[<span class="keyword">ADD</span> [<span class="keyword">COLUMN</span>] &lt;新列名&gt;&lt;数据类型&gt; [完整性约束]]</div><div class="line">[<span class="keyword">ADD</span> &lt;表级完整性约束&gt;]</div><div class="line">[<span class="keyword">DROP</span> [<span class="keyword">COLUMN</span>] &lt;列名&gt; [<span class="keyword">CASCADE</span>|RESTRICT]]</div><div class="line">[<span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> &lt;完整性约束&gt; [RESTRICT|<span class="keyword">CASCADE</span>]]</div><div class="line">[<span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> &lt;列名&gt;&lt;数据类型&gt;];</div></pre></td></tr></table></figure>
<h3 id="5-删除基本表">5. 删除基本表</h3>
<p><code>DROP TABLE &lt;表名&gt; [RESTRICT|CASCADE]</code></p>
<p>不同的数据库产品在遵循 SQL 标准的基础上具体实现细节和处理策略会与标准有差别。</p>
<h2 id="索引的建立与删除">索引的建立与删除</h2>
<p>建立索引时加快查询速度的有效手段。索引是关系数据库管理系统的内部实现技术，属于内模式范畴。用户不必也不能显式地选择索引。</p>
<p>常见的数据库索引：</p>
<ul>
<li>顺序文件上的索引；</li>
<li>B+树索引</li>
<li>散列索引</li>
<li>位图索引</li>
</ul>
<h3 id="1-建立索引">1. 建立索引</h3>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>] [CLUSTER] <span class="keyword">INDEX</span> &lt;索引名&gt;</div><div class="line"><span class="keyword">ON</span> &lt;表名&gt;(&lt;列名&gt; [&lt;次序&gt;][,&lt;列名&gt; [&lt;次序&gt;]] ...);</div></pre></td></tr></table></figure>
<h3 id="2-修改索引">2. 修改索引</h3>
<p><code>ALTER INDEX &lt;旧索引名&gt;RENAME TO&lt;新索引名&gt;</code></p>
<h3 id="3-删除索引">3. 删除索引</h3>
<p><code>DROP INDEX &lt;索引名&gt;</code></p>
<h2 id="数据字典">数据字典</h2>
<blockquote>
<p>数据字典时关系数据库管理系统内部的一组系统表，它记录了数据库中所有的定义信息，包括关系模式定义、视图定义、索引定义、完整性约束定义、各类用户对数据库的操作权限、统计信息等。关系数据库管理系统在执行 SQL 的数据定义语句时，实际上就是在更新数据字典表中的相应信息。在进行查询优化和查询处理时，数据字典中的信息是其重要依据。</p>
</blockquote>
<hr>
<h1 id="数据查询">数据查询</h1>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> [ALL|<span class="keyword">DISTINCT</span>] &lt;目标列表达式&gt; [,&lt;目标列表达式&gt;]...</div><div class="line"><span class="keyword">FROM</span> &lt;表名或视图名&gt; [,&lt;表名或视图名&gt;]|(&lt;<span class="keyword">SELECT</span> 语句&gt;)[<span class="keyword">AS</span>]&lt;别名&gt;</div><div class="line">[<span class="keyword">WHERE</span> &lt;条件表达式&gt;]</div><div class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;列名<span class="number">1</span>&gt; [<span class="keyword">HAVING</span> &lt;条件表达式&gt;]]</div><div class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;列名<span class="number">2</span>&gt; [<span class="keyword">ASC</span>|<span class="keyword">DESC</span>]];</div></pre></td></tr></table></figure>
<h2 id="单表查询">单表查询</h2>
<ol>
<li>选择表中若干列</li>
<li>选择表中若干元组</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">查询条件</th>
<th style="text-align:left">谓词</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">比较</td>
<td style="text-align:left"><code>=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>!=</code>, <code>&lt;&gt;</code>, <code>!&gt;</code>, <code>!&lt;</code>; <code>NOT+上述比较运算符</code></td>
</tr>
<tr>
<td style="text-align:left">确定范围</td>
<td style="text-align:left"><code>BETWEEN AND</code>, <code>NOT BETWEEN AND</code></td>
</tr>
<tr>
<td style="text-align:left">确定集合</td>
<td style="text-align:left"><code>IN</code>, <code>NOT IN</code></td>
</tr>
<tr>
<td style="text-align:left">字符匹配</td>
<td style="text-align:left"><code>LIKE</code>, <code>NOT LIKE</code></td>
</tr>
<tr>
<td style="text-align:left">空值</td>
<td style="text-align:left"><code>IS NULL</code>, <code>IS NOT NULL</code></td>
</tr>
<tr>
<td style="text-align:left">多重条件（逻辑运算）</td>
<td style="text-align:left"><code>AND</code>, <code>OR</code>, <code>NOT</code></td>
</tr>
</tbody>
</table>
<ol start="3">
<li><code>OBDER BY</code> 子句</li>
<li>聚集函数</li>
<li><code>GROUP BY</code> 子句</li>
</ol>
<h2 id="连接查询">连接查询</h2>
<p>连接查询：查询同时涉及两个以上的表。</p>
<ol>
<li>等值与非等值连接的查询</li>
<li>自身连接</li>
<li>外连接</li>
<li>多表连接</li>
</ol>
<h2 id="嵌套查询">嵌套查询</h2>
<blockquote>
<p>在 SQL 语言中，一个 <code>SELECT-FROM-WHERE</code> 语句称为一个查询块。将一个查询块嵌套再另一个查询块的 <code>WHERE</code> 子句或 <code>HAVING</code> 短语的条件中的查询称为嵌套查询。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> Sname <span class="comment">/*外层查询或父查询*/</span></div><div class="line"><span class="keyword">FROM</span> Student</div><div class="line"><span class="keyword">WHERE</span> Sno <span class="keyword">IN</span></div><div class="line">    (<span class="keyword">SELECT</span> Sno <span class="comment">/*内层查询或子查询*/</span></div><div class="line">    <span class="keyword">FROM</span> SC</div><div class="line">    <span class="keyword">WHERE</span> Cno=<span class="string">'2'</span>);</div></pre></td></tr></table></figure>
<ol>
<li>带有 <code>IN</code> 谓词的子查询</li>
<li>带有比较运算符的子查询</li>
<li>带有 <code>ANY (SOME)</code> 或 <code>ALL</code> 谓词的子查询</li>
<li>带有 <code>EXISTS</code> 谓词的子查询</li>
</ol>
<h2 id="集合查询">集合查询</h2>
<blockquote>
<p>集合操作主要包括并操作 <code>UNION</code>、交操作 <code>INTERSECT</code> 和差操作 <code>EXCEPT</code>。参加集合操作的各查询结果的<strong>列数</strong>必须相同；对应项的<strong>数据类型</strong>也必须相同。</p>
</blockquote>
<h2 id="基于派生表的查询">基于派生表的查询</h2>
<blockquote>
<p>子查询不仅可以出现在 <code>WHERE</code> 子句中，还可以出现再 <code>FROM</code> 子句中，这时子查询生成的临时派生表称为主查询的查询对象。</p>
</blockquote>
<hr>
<h1 id="数据更新">数据更新</h1>
<h2 id="插入数据">插入数据</h2>
<ol>
<li>插入元组</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">INSERT</span></div><div class="line"><span class="keyword">INTO</span> &lt;表名&gt; [(&lt;属性列 <span class="number">1</span>&gt; [, &lt;属性列 <span class="number">2</span>&gt;] ...)]</div><div class="line"><span class="keyword">VALUES</span> (&lt;常量 <span class="number">1</span>&gt; [,&lt;常量 <span class="number">2</span>&gt;]); <span class="comment">-- 字符串常量使用单引号括起来</span></div></pre></td></tr></table></figure>
<ol start="2">
<li>插入子查询结果</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">INSERT</span></div><div class="line"><span class="keyword">INTO</span> &lt;表名&gt; [(&lt;属性列 <span class="number">1</span>&gt; [, &lt;属性列 <span class="number">2</span>&gt;] ...)]</div><div class="line">子查询;</div></pre></td></tr></table></figure>
<h2 id="修改数据">修改数据</h2>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">UPDATE</span> &lt;<span class="keyword">TABLE</span>&gt;</div><div class="line"><span class="keyword">SET</span> &lt;<span class="keyword">column</span>&gt;=&lt;expression&gt; [,&lt;<span class="keyword">column</span>&gt;=&lt;expression&gt;]</div><div class="line">[<span class="keyword">WHERE</span> &lt;condition&gt;];</div></pre></td></tr></table></figure>
<h2 id="删除数据">删除数据</h2>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">DELETE</span></div><div class="line"><span class="keyword">FROM</span> &lt;<span class="keyword">table</span>&gt;</div><div class="line">[<span class="keyword">WHERE</span> &lt;condition&gt;];</div></pre></td></tr></table></figure>
<hr>
<h1 id="空值的处理">空值的处理</h1>
<p>空值：不知道或者不存在或者无意义的值。</p>
<p>以下条件取空值：</p>
<ul>
<li>该属性应该有一个值，但目前不知道；</li>
<li>该属性不应该有值；</li>
<li>由于某种原因不便于填写。</li>
</ul>
<p>空值的判断：<code>IS NULL</code> <code>IS NOT NULL</code>。</p>
<hr>
<h1 id="视图">视图</h1>
<p><code>CREATE VIEW</code><br>
<code>ALTER VIEW</code><br>
<code>DROP VIEW</code><br>
<code>SHOW VIEW</code></p>
<h2 id="视图的作用">视图的作用</h2>
<ul>
<li>简化用户操作</li>
<li>使用户以多种角度看待同一数据</li>
<li>对重构数据库提供了一定程度的逻辑独立性</li>
<li>对机密数据提供安全保护</li>
<li>适当利用视图可以更清晰地表达查询</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《数据库系统概论》第三章笔记。&lt;/p&gt;
&lt;h1 id=&quot;基础&quot;&gt;基础&lt;/h1&gt;
&lt;h2 id=&quot;sql-历史&quot;&gt;SQL 历史&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;1974 年，Boyce 和 Chamberlin 提出，Sequel&lt;/li&gt;
&lt;li&gt;1986 年 10 月，美国国
    
    </summary>
    
      <category term="Notes" scheme="blog.alexiangli.com/categories/Notes/"/>
    
      <category term="Database" scheme="blog.alexiangli.com/categories/Notes/Database/"/>
    
    
      <category term="Database" scheme="blog.alexiangli.com/tags/Database/"/>
    
      <category term="SQL" scheme="blog.alexiangli.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>R：向量化运算</title>
    <link href="blog.alexiangli.com/r-apply-family/"/>
    <id>blog.alexiangli.com/r-apply-family/</id>
    <published>2016-09-13T14:50:21.000Z</published>
    <updated>2016-11-28T12:42:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Updated in 2016-11-12</p>
</blockquote>
<p>学习 <code>sapply</code> <code>lapply</code> <code>apply</code> <code>tapply</code> <code>by</code> <code>aggregate</code> 等向量化运算函数的笔记。</p>
<h1 id="apply"><code>apply</code></h1>
<p>当输入数据为矩阵或数组时使用，如果输入数据为 <code>data.frame</code>，则不建议使用。</p>
<p><code>apply(X, MARGIN, FUN, ...)</code></p>
<ul>
<li><code>X</code> 数组或矩阵</li>
<li><code>MARGIN</code> 指定 <code>FUN</code> 作用的由下标组成的向量。若 <code>X</code> 为矩阵，1 表示行，2 表示列。<code>c(1,2)</code> 表示行和列。如果 <code>X</code> 包含 <code>dimnames</code>，那么也可以为字符向量。</li>
<li><code>FUN</code> 使用的函数</li>
</ul>
<p>如果需要在行或者列上求均值和求和，则建议使用 <code>colMeans</code> <code>rowMeans</code> <code>colSums</code> <code>rowSums</code>。</p>
<h1 id="tapply"><code>tapply</code></h1>
<p>需要对向量按组或者因素水平计算，类似于 <code>split-apply-combine</code>。</p>
<h1 id="by"><code>by</code></h1>
<p>可替代 <code>tapply</code>，在无法使用 <code>tapply</code> 的情况下仍然可用。</p>
<p><a href="http://stackoverflow.com/a/32262439/6469987" target="_blank" rel="external">参考</a></p>
<h1 id="aggregate"><code>aggregate</code></h1>
<p>跟 <code>tapply</code> 类似，不同的是，<code>aggregate</code> 的第二个参数必须为 list，输出为 data.frame。<code>aggregate</code> 的参数还可以为 formula。需要主要的是 <code>aggregate</code> 的 formula 方法默认 <code>na.action = na.omit</code>，所以需要手动设置参数 <code>na.rm = TRUE</code>。</p>
<h1 id="lapply"><code>lapply</code></h1>
<p>输入和输出都为 list。其他 <code>*apply</code> 函数底层都是调用 <code>lapply</code> 函数。</p>
<p><code>lapply(X, FUN, ...)</code></p>
<p>返回与 <code>X</code> 等长度的 list，每个元素是由 <code>X</code> 中的元素经过 <code>FUN</code> 计算得到。</p>
<h1 id="sapply"><code>sapply</code></h1>
<p>输入为 list，但输出为 vector。</p>
<p><code>sapply(X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE)</code></p>
<p>比 <code>lapply</code> 更友好，虽然默认返回 vector，matrix，但是如果增加 <code>simplify = &quot;array&quot;</code> 的参数，将返回 array。<code>sapply(x, f, simplify=FALSE, USE.NAMES = FALSE)</code> 等同于 <code>lapply(x, f)</code>。</p>
<h1 id="vapply"><code>vapply</code></h1>
<p><code>vapply(X, FUN, FUN.VALUE, ..., USE.NAMES = TRUE)</code></p>
<p>类似与 <code>sapply</code>，但是返回值的类型是事先确定。</p>
<h1 id="replicate"><code>replicate</code></h1>
<p>重复地执行表达式。</p>
<h1 id="其他相关函数">其他相关函数</h1>
<p><code>outer</code> <code>ave</code> <code>eapply</code></p>
<h1 id="比较好的总结">比较好的总结</h1>
<blockquote>
<ul>
<li><strong>lapply</strong> is a list apply which acts on a list or vector and returns a list.</li>
<li><strong>sapply</strong> is a simple lapply (function defaults to returning a vector or matrix when possible)</li>
<li><strong>vapply</strong> is a verified apply (allows the return object type to be prespecified)</li>
<li><strong>rapply</strong> is a recursive apply for nested lists, i.e. lists within lists</li>
<li><strong>tapply</strong> is a tagged apply where the tags identify the subsets</li>
<li><strong>apply</strong> is generic: applies a function to a matrix’s rows or columns (or, more generally, to dimensions of an array)</li>
</ul>
</blockquote>
<p><a href="http://stackoverflow.com/a/23282110/6469987" target="_blank" rel="external">参考</a></p>
<hr>
<p>参考资料</p>
<ul>
<li><a href="https://stackoverflow.com/questions/3505701/r-grouping-functions-sapply-vs-lapply-vs-apply-vs-tapply-vs-by-vs-aggrega" target="_blank" rel="external">R Grouping functions: sapply vs. lapply vs. apply. vs. tapply vs. by vs. aggregate</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Updated in 2016-11-12&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;学习 &lt;code&gt;sapply&lt;/code&gt; &lt;code&gt;lapply&lt;/code&gt; &lt;code&gt;apply&lt;/code&gt; &lt;code&gt;tapply&lt;/code&gt;
    
    </summary>
    
      <category term="Notes" scheme="blog.alexiangli.com/categories/Notes/"/>
    
      <category term="R" scheme="blog.alexiangli.com/categories/Notes/R/"/>
    
    
      <category term="R" scheme="blog.alexiangli.com/tags/R/"/>
    
      <category term="R-basics" scheme="blog.alexiangli.com/tags/R-basics/"/>
    
  </entry>
  
  <entry>
    <title>MySQL安装与配置（MacOS）</title>
    <link href="blog.alexiangli.com/mysql-config/"/>
    <id>blog.alexiangli.com/mysql-config/</id>
    <published>2016-09-13T12:59:16.000Z</published>
    <updated>2016-11-28T12:42:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="下载-mysql">下载 MySQL</h1>
<p>从<a href="http://www.mysql.com/downloads/" target="_blank" rel="external">官方网站</a>下载 <code>MySQL Community Server</code>。</p>
<h1 id="安装-mysql">安装 MySQL</h1>
<p>在网上教程发现提到这三个文件</p>
<ol>
<li>mysql-*.pkg：MySql的主要程序包</li>
<li>MySQL_StartupItem.pkg：MySql的启动项</li>
<li>MySQL.prefPane：MySQL的偏好设置，主要用来启动MySQL服务</li>
</ol>
<p>但是打开 dmg 文件，仅仅发现一个 mysql-<version>.pkg 文件</version></p>
<h1 id="安装-mysql-workbench-gui-tool">安装 MySQL Workbench（GUI Tool）</h1>
<p>仍然从官网下载。下载后安装然后进行配置。</p>
<p>数据库访问密码的设置</p>
<blockquote>
<p>MySQL的默认账号密码是root/root，正常情况下我们如果单纯的只是使用MySQL Workbench来管理数据库的这个账号是可以的，但是当我们在编程代码中通过jdbc来访问MySQL时我们就会发现使用这个账号是不行，无法访问，因为MySQL需要我们更改密码，也就是说root这个是个默认的密码也就是弱密码，需要我们修改之后才能在代码中使用。</p>
</blockquote>
<h1 id="添加到-path">添加到 <strong>PATH</strong></h1>
<p>将 <code>/usr/local/mysql/bin</code> 添加到 <code>PATH</code> 中<br>
编辑 <code>.bash_profile</code> 加入 <code>export PATH=$PATH:/usr/local/mysql/bin</code></p>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo &quot;export PATH=$PATH:/usr/local/mysql/bin&quot; &gt;&gt; ~/.bash_profile</div></pre></td></tr></table></figure>
<h1 id="报错">报错</h1>
<p>查询 MySQL 版本是 <code>mysql -v</code> 报错：<br>
<code>Can't connect to local MySQL server through socket '/tmp/mysql.sock'</code></p>
<p>网上寻找教程，发现有解决办法是对 <code>mysql.sock</code> 建立符号链接。但是在 Mac 上并未找到这个文件。</p>
<p><s>寻找 <code>mysql.sock</code> 文件：<code>find / -name &quot;mysql.sock&quot;</code> 得到 <code>/var/lib/mysql/mysql.sock</code><br>
那么建立 <code>symbolic link</code>：<code>ln -s /var/lib/mysql/mysql.sock /tmp/mysql.sock</code></s></p>
<p>后来发现，这个报错是因为 <code>MySQL Server</code> 没有运行。于是打开 <code>MySQL.prefPane</code>，打开 <code>MySQL Server</code>。</p>
<p>又出现另外的报错 <code>ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: YES)</code>。</p>
<p>检索相关问题发现导致这个报错的原因有以下三种：</p>
<ol>
<li>客户端远程访问的用户帐号并未创建；</li>
<li>用户帐号存在，但未对其所在的客户端的 IP 进行远程访问授权允许；</li>
<li>用户帐号授权访问的密码不正确。</li>
</ol>
<p>看到前面安装 GUI 工具的部分说到，必须重新设置账户密码，root 的密码为弱密码。</p>
<p>MySQL 还有个配置文件 <code>my.cnf</code>，里面可以设置帐号密码。</p>
<p><strong>最后发现</strong>，原来在安装 MySQL 时，弹出来一个临时密码的提醒，这个密码用于第一次登录 MySQL，并修改密码。现在终于想起来那个临时密码，但是已经忘了有没有保存。因为自己挖的坑，折腾了很久。</p>
<p>于是为了图方便，先把 MySQL 完全卸载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># first stop the database server</div><div class="line">sudo rm /usr/local/mysql</div><div class="line">sudo rm -rf /usr/local/mysql*</div><div class="line">sudo rm -rf /Library/StartupItems/MySQLCOM</div><div class="line">sudo rm -rf /Library/PreferencePanes/My*</div><div class="line"># edit /etc/hostconfig and remove the line MYSQLCOM=-YES-</div><div class="line">rm -rf ~/Library/PreferencePanes/My*</div><div class="line">sudo rm -rf /Library/Receipts/mysql*</div><div class="line">sudo rm -rf /Library/Receipts/MySQL*</div><div class="line">sudo rm -rf /private/var/db/receipts/*mysql*</div><div class="line">sudo rm -rf /var/db/receipts/com.mysql.*</div></pre></td></tr></table></figure>
<p>然后再重新安装 MySQL。</p>
<p>这次长记性保存了临时密码。</p>
<p>接下来重新配置 MySQL。</p>
<p>修改根用户密码：<code>mysqldmin -u root -p password</code><br>
提示输入旧密码，然后输入新密码，最后确认新密码。然后会得到以下提示：</p>
<blockquote>
<p>Warning: Since password will be sent to server in plain text, use ssl connection to ensure password safety.</p>
</blockquote>
<p>通过新修改的密码登录 MySQL：<code>mysql -u root -p</code>，提示输入密码，终于成功登录。</p>
<p>吸取教训，<strong>一定不要完全按照网上的教程来安装配置应用程序，尽量根据官网文档</strong>。</p>
<hr>
<p>参考资料：</p>
<ul>
<li><a href="http://www.cnblogs.com/macro-cheng/archive/2011/10/25/mysql-001.html" target="_blank" rel="external">MAC下安装与配置MySQL</a></li>
<li><a href="http://blog.csdn.net/zzq900503/article/details/14163341" target="_blank" rel="external">Can’t connect to local MySQL server through socket ‘/tmp/mysql.sock’</a></li>
<li><a href="https://segmentfault.com/q/1010000000094608" target="_blank" rel="external">Mac上MySQL报错</a></li>
<li><a href="http://obscuredclarity.blogspot.in/2009/08/install-mysql-on-mac-os-x.html" target="_blank" rel="external">Install MySQL on Mac OS X</a></li>
<li><a href="http://blog.csdn.net/lioncode/article/details/7917310" target="_blank" rel="external">连接MySQL数据库时常见故障问题的分析与解决</a></li>
<li><a href="http://stackoverflow.com/questions/1436425/how-do-you-uninstall-mysql-from-mac-os-x" target="_blank" rel="external">How do you uninstall MySQL from Mac OS X?</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/osx-installation-pkg.html" target="_blank" rel="external">Installing MySQL on OS X Using Native Packages</a></li>
<li><a href="http://community.jaspersoft.com/wiki/uninstall-mysql-mac-os-x" target="_blank" rel="external">Uninstall MySql on a Mac OS X</a></li>
<li><a href="https://www.howtoforge.com/setting-changing-resetting-mysql-root-passwords" target="_blank" rel="external">Setting, Changing And Resetting MySQL Root Passwords</a></li>
<li><a href="http://stackoverflow.com/questions/33387879/mysql-password-expired-cant-connect" target="_blank" rel="external">Mysql password expired. Can’t connect</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;下载-mysql&quot;&gt;下载 MySQL&lt;/h1&gt;
&lt;p&gt;从&lt;a href=&quot;http://www.mysql.com/downloads/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方网站&lt;/a&gt;下载 &lt;code&gt;MySQL Communit
    
    </summary>
    
      <category term="Original" scheme="blog.alexiangli.com/categories/Original/"/>
    
      <category term="Config" scheme="blog.alexiangli.com/categories/Original/Config/"/>
    
    
      <category term="Database" scheme="blog.alexiangli.com/tags/Database/"/>
    
      <category term="Configuration" scheme="blog.alexiangli.com/tags/Configuration/"/>
    
      <category term="MySQL" scheme="blog.alexiangli.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>数据冗余</title>
    <link href="blog.alexiangli.com/data-redundency/"/>
    <id>blog.alexiangli.com/data-redundency/</id>
    <published>2016-09-10T16:00:00.000Z</published>
    <updated>2017-01-27T08:19:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据冗余">数据冗余</h1>
<h2 id="什么是数据冗余？">什么是数据冗余？</h2>
<p><code>数据冗余</code> 是指<strong>同一个数据</strong>在系统中<strong>多次重复</strong>出现。</p>
<p>数据库系统仅仅降低了数据冗余，仍然存在数据冗余问题。消除数据冗余的目的是为了避免更新时可能出现的问题，以便<strong>保持数据的一致性</strong>。</p>
<p>Q: 数据冗余会造成什么影响和后果？</p>
<h2 id="数据冗余的类型">数据冗余的类型</h2>
<ul>
<li>空间冗余</li>
<li>时间冗余</li>
<li>结构冗余</li>
<li>知识冗余</li>
<li>视觉冗余</li>
<li>信息熵冗余</li>
</ul>
<p>Q：数据冗余与文件压缩有什么样的关系？</p>
<h2 id="什么时候增加数据冗余？">什么时候增加数据冗余？</h2>
<p>虽然一般情况下，应尽量减少数据冗余，保证数据的一致性，但在某些情况下，也需要适当增加数据冗余度。数据冗余或者信息冗余是生产、生活所必然存在的行为，没有好与坏的总体倾向。</p>
<ul>
<li>重复存储或传输数据以<strong>防止数据丢失</strong>；</li>
<li>对数据进行冗余性的编码来防止数据的丢失、错误，并提供<strong>对错误数据进行反变换</strong>得到原始数据的功能；</li>
<li>为方便处理和使同一信息在不同地点有<strong>不同的表现形式</strong>；</li>
<li>为了提高数据的<strong>检索速度</strong>。</li>
</ul>
<hr>
<p>参考资料：</p>
<ul>
<li><a href="http://wiki.mbalib.com/wiki/%E6%95%B0%E6%8D%AE%E5%86%97%E4%BD%99" target="_blank" rel="external">wiki.mbalib.com/wiki/数据冗余</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据冗余&quot;&gt;数据冗余&lt;/h1&gt;
&lt;h2 id=&quot;什么是数据冗余？&quot;&gt;什么是数据冗余？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;数据冗余&lt;/code&gt; 是指&lt;strong&gt;同一个数据&lt;/strong&gt;在系统中&lt;strong&gt;多次重复&lt;/strong&gt;出现。&lt;/p&gt;
&lt;p&gt;数据库
    
    </summary>
    
      <category term="Notes" scheme="blog.alexiangli.com/categories/Notes/"/>
    
    
      <category term="Database" scheme="blog.alexiangli.com/tags/Database/"/>
    
  </entry>
  
</feed>
